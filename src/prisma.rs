// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::{
    bigdecimal::{self, FromPrimitive},
    chrono,
    datamodel::parse_configuration,
    operator::Operator,
    prisma_models::{InternalDataModelBuilder, PrismaValue},
    queries::{QueryContext, QueryInfo, Result as QueryResult},
    query_core::{
        executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
        QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
    },
    serde_json, transform_equals, BatchResult, Direction, ManyArgs, SerializedWhere,
    SerializedWhereValue, UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"cargo r\"\n  output = \"src/prisma.rs\"\n}\n\n\n// --------------------------------------\n\nenum UserBadge {\n  PREMIUM // Has subscribed to the premium service\n  MATURE // Has 18+ NSFW content (moderator actionable)\n  NOT_SAFE // Has had around for a small amount of time, or many reports (moderator actionable)\n  SAFE // Has been around for 2-3 months and no reports (moderator actionable)\n  TRUSTED // (moderator actionable)\n  MODERATOR // Ability to add, remove\n  ADMINISTRATOR\n  SUPERADMIN // Total developer control of website\n}\n\nenum PremiumFeature {\n  CUSTOM_PROFILE\n  UNLIMITED_UPLOADS\n}\n\nenum SafetyRating {\n  TRUSTED // Uploaded by a trusted user (or manually marked as trusted)\n  SAFE // Uploaded by known users (or manually marked as safe)\n  UNKNOWN // Not bad but not good, neutral state for unknown images\n  NOT_SAFE // Potentially unsafe content\n  MATURE // 18+ NSFW content\n}\n\nenum LockingStatus {\n  LOCKED // Not visible by anyone, not editable by anyone, not linkable\n  HIDDEN // Not visible in any featured lists or search results, visible on user profiles or direct linking\n  NONE // No restrictions\n}\n\nenum UserConnectionType {\n  EMAIL\n\n  GOOGLE\n  DISCORD\n  TWITTER\n  LINKEDIN\n}\n\nenum GroupMemberRole {\n  NONE\n  ADMINISTRATOR // Has the ability to add and edit images/albums owned by the group\n  OWNER // Has ability to add and remove admins\n}\n\nenum UserRole {\n  NONE\n  MATURE // Has 18+ NSFW content (moderator actionable)\n  NOT_SAFE // Has had around for a small amount of time, or many reports (moderator actionable)\n  SAFE // Has been around for 2-3 months and no reports (moderator actionable)\n  TRUSTED // (moderator actionable)\n  MODERATOR // Ability to add, remove\n  ADMINISTRATOR\n  SUPERADMIN // Total developer control of website\n}\n\nmodel Group {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  name        String @unique\n  displayName String\n\n  members GroupMember[]\n\n  images Image[]\n  albums Album[]\n\n  user                   User?                    @relation(fields: [userId], references: [id])\n  userId                 String?\n}\n\nmodel GroupMember {\n  id String @id @unique\n\n  role GroupMemberRole @default(NONE)\n\n  group   Group  @relation(fields: [groupId], references: [id])\n  groupId String\n\n  user   User   @relation(fields: [userId], references: [id])\n  userId String\n\n  invitedAt DateTime @default(now())\n\n  @@unique([groupId, userId])\n}\n\nmodel User {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  username String  @unique\n  nickname String?\n\n  bio String?\n\n  // WARNING: DEPRECATED - Use 'permissions' instead.\n  role UserRole @default(NONE)\n\n  permissions    Int @default(130048) // 130048 = USER_DEFAULT_PERMISSIONS\n\n  email          String  @unique\n  hashedPassword String?\n\n  avatarUrl String?\n  avatarSourceId String? // Overrides the 'avatarUrl' from outside connections\n\n  bannerExt String @default(\"png\") // The ext of the user's banner\n\n  badges UserBadge[]\n\n  lockStatus LockingStatus @default(NONE)\n\n  reports         Report[]         @relation(name: \"UserWasReported\")\n  createdReports  Report[]         @relation(name: \"UserIsReporter\")\n  memberships     GroupMember[]\n  connections     UserConnection[]\n  premiumFeatures PremiumFeature[]\n\n  tokens   Token[]\n  sessions Session[]\n\n  albums Album[]\n  images Image[]\n  groups Group[]\n\n  notifications          Notification[]\n  moderatorNotifications ModeratorNotifications[]\n\n  favouriteUsers  User[]  @relation(name: \"UserFavouriteUsers\")\n  favouriteAlbums Album[] @relation(name: \"UserFavouriteAlbums\")\n  favouriteImages Image[] @relation(name: \"UserFavouriteImages\")\n\n  userFavourites   User[]   @relation(\"UserFavouriteUsers\", references: [id])\n  userFavouriteIds String[]\n}\n\nmodel UserConnection {\n  // https://github.com/SeaQL/sea-orm/issues/126#issuecomment-912725227\n  id String @id @default(cuid())\n  conn_type UserConnectionType\n\n  email        String\n  handle       String? // The linkable profile connection handle\n\n  accessToken  String?\n  refreshToken String?\n\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  expiresAt DateTime?\n\n  user   User   @relation(fields: [userId], references: [id])\n  userId String\n\n  @@unique([email, conn_type])\n}\n\nmodel Session {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  expiresAt          DateTime?\n  handle             String    @unique\n  hashedSessionToken String?\n  antiCSRFToken      String?\n  publicData         String?\n  privateData        String?\n\n  user   User?   @relation(fields: [userId], references: [id])\n  userId String?\n}\n\nmodel Token {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  hashedToken String\n  tok_type        String\n  expiresAt   DateTime\n  sentTo      String\n\n  user   User   @relation(fields: [userId], references: [id])\n  userId String\n\n  @@unique([hashedToken, tok_type])\n}\n\nmodel Category {\n  slug    String @id @unique\n  display String\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  album   Album  @relation(fields: [albumId], references: [id])\n  albumId String\n\n  image   Image  @relation(fields: [imageId], references: [id])\n  imageId String\n\n  lockStatus LockingStatus @default(NONE)\n  rating     SafetyRating  @default(UNKNOWN)\n\n  @@index([albumId, imageId])\n}\n\nmodel Image {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  imageExt String\n\n  colors   Int[]\n\n  title       String?\n  description String?\n\n  author   User   @relation(fields: [authorId], references: [id])\n  authorId String\n\n  group   Group?  @relation(fields: [groupId], references: [id])\n  groupId String?\n\n  categories Category[]\n\n  album   Album  @relation(fields: [albumId], references: [id])\n  albumId String\n\n  lockStatus LockingStatus @default(NONE)\n  rating     SafetyRating  @default(UNKNOWN)\n\n  userFavourites   User[]   @relation(\"UserFavouriteImages\", references: [id])\n  userFavouriteIds String[]\n\n  Report Report[]\n  @@index([id, authorId])\n}\n\nmodel Album {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now()) @updatedAt\n\n  coverExt String\n  colors   Int[]\n\n  title       String?\n  description String?\n\n  author   User   @relation(fields: [authorId], references: [id])\n  authorId String\n\n  group   Group?  @relation(fields: [groupId], references: [id])\n  groupId String?\n\n  images     Image[]\n  categories Category[]\n\n  lockStatus LockingStatus @default(NONE)\n  rating     SafetyRating  @default(UNKNOWN)\n\n  userFavourites   User[]   @relation(\"UserFavouriteAlbums\", references: [id])\n  userFavouriteIds String[]\n\n  Report Report[]\n  @@index([id, authorId])\n}\n\nenum ReportReason {\n  MATURE\n  SPAM\n  VIOLENCE\n  HARASSMENT\n  OTHER\n}\n\nmodel Report {\n  id        String   @id @unique\n  createdAt DateTime @default(now())\n\n  album   Album?  @relation(fields: [albumId], references: [id])\n  albumId String?\n\n  image   Image?  @relation(fields: [imageId], references: [id])\n  imageId String?\n\n  user   User?   @relation(\"UserWasReported\", fields: [userId], references: [id])\n  userId String?\n\n  reportee   User   @relation(\"UserIsReporter\", fields: [reporteeId], references: [id])\n  reporteeId String\n\n  reason String\n\n  @@index([albumId, imageId, userId])\n}\n\nenum NotificationType {\n  RANDOM_INFO // Any sort of title & message combo\n\n  NEW_FAVOURITE\n  NEW_FOLLOWER\n\n  SUBSCRIPTION_ACTIVE\n  SUBSCRIPTION_EXPIRING_SOON\n  SUBSCRIPTION_EXPIRED\n\n  USER_MARKED_AS_MATURE_BY_MODERATOR\n  USER_MARKED_AS_NOT_MATURE_BY_MODERATOR\n\n  USER_MARKED_AS_TRUSTED_BY_MODERATOR\n  USER_MARKED_AS_NOT_TRUSTED_BY_MODERATOR\n\n  ALBUM_LOCKED_BY_MODERATOR\n  ALBUM_UNLOCKED_BY_MODERATOR\n  ALBUM_DELETED_BY_MODERATOR\n\n  IMAGE_LOCKED_BY_MODERATOR\n  IMAGE_UNLOCKED_BY_MODERATOR\n  IMAGE_DELETED_BY_MODERATOR\n\n  NEW_GROUP_INVITE\n\n  GROUP_MEMBER_JOINED\n  GROUP_MEMBER_LEFT\n\n  GROUP_MEMBER_INVITE_ACCEPTED\n  GROUP_MEMBER_INVITE_DECLINED\n  GROUP_MEMBER_INVITE_EXPIRED\n}\n\nmodel Notification {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n\n  not_type NotificationType\n\n  title   String\n  message String\n\n  user    User?   @relation(fields: [userId], references: [id])\n  userId  String?\n}\n\nenum ModeratorNotificationsType {\n  NEW_REPORT\n  SUSPICIOUS_ACTIVITY\n}\n\nmodel ModeratorNotifications {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n\n  not_type ModeratorNotificationsType\n\n  title   String\n  message String\n\n  user    User?   @relation(fields: [userId], references: [id])\n  userId  String?\n\n}\n" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod group {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Name(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayNameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DisplayNameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DisplayNameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DisplayNameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DisplayNameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DisplayNameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DisplayNameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DisplayNameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DisplayNameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DisplayNameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDisplayName(value.0)
            }
        }
    }
    pub mod members {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembersSome(value)
        }
        pub fn every(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembersEvery(value)
        }
        pub fn none(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembersNone(value)
        }
        pub struct Fetch {
            args: group_member::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group_member::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: group_member::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<group_member::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Members(fetch.args)
            }
        }
        pub fn fetch(params: Vec<group_member::WhereParam>) -> Fetch {
            Fetch {
                args: group_member::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<group_member::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<group_member::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkMembers(params)
        }
        pub struct Link(Vec<group_member::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkMembers(value.0)
            }
        }
    }
    pub mod images {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesSome(value)
        }
        pub fn every(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesEvery(value)
        }
        pub fn none(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesNone(value)
        }
        pub struct Fetch {
            args: image::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: image::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<image::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Images(fetch.args)
            }
        }
        pub fn fetch(params: Vec<image::WhereParam>) -> Fetch {
            Fetch {
                args: image::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<image::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<image::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkImages(params)
        }
        pub struct Link(Vec<image::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkImages(value.0)
            }
        }
    }
    pub mod albums {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsSome(value)
        }
        pub fn every(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsEvery(value)
        }
        pub fn none(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsNone(value)
        }
        pub struct Fetch {
            args: album::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: album::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<album::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Albums(fetch.args)
            }
        }
        pub fn fetch(params: Vec<album::WhereParam>) -> Fetch {
            Fetch {
                args: album::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<album::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<album::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkAlbums(params)
        }
        pub struct Link(Vec<album::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAlbums(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "name",
            "displayName",
            "userId",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        #[serde(rename = "members")]
        pub members: Option<Vec<super::group_member::Data>>,
        #[serde(rename = "images")]
        pub images: Option<Vec<super::image::Data>>,
        #[serde(rename = "albums")]
        pub albums: Option<Vec<super::album::Data>>,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<String>,
    }
    impl Data {
        pub fn members(&self) -> Result<&Vec<super::group_member::Data>, &'static str> {
            self.members.as_ref().ok_or(
                "Attempted to access 'members' but did not fetch it using the .with() syntax",
            )
        }
        pub fn images(&self) -> Result<&Vec<super::image::Data>, &'static str> {
            self.images
                .as_ref()
                .ok_or("Attempted to access 'images' but did not fetch it using the .with() syntax")
        }
        pub fn albums(&self) -> Result<&Vec<super::album::Data>, &'static str> {
            self.albums
                .as_ref()
                .ok_or("Attempted to access 'albums' but did not fetch it using the .with() syntax")
        }
        pub fn user(&self) -> Result<Option<&super::user::Data>, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    pub enum WithParam {
        Members(super::group_member::ManyArgs),
        Images(super::image::ManyArgs),
        Albums(super::album::ManyArgs),
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Members(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::group_member::_outputs());
                    let mut builder = Selection::builder("members");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Images(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::image::_outputs());
                    let mut builder = Selection::builder("images");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Albums(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::album::_outputs());
                    let mut builder = Selection::builder("albums");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetName(String),
        SetDisplayName(String),
        LinkMembers(Vec<super::group_member::UniqueWhereParam>),
        UnlinkMembers(Vec<super::group_member::UniqueWhereParam>),
        LinkImages(Vec<super::image::UniqueWhereParam>),
        UnlinkImages(Vec<super::image::UniqueWhereParam>),
        LinkAlbums(Vec<super::album::UniqueWhereParam>),
        UnlinkAlbums(Vec<super::album::UniqueWhereParam>),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(Option<String>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value)),
                SetParam::SetDisplayName(value) => {
                    ("displayName".to_string(), PrismaValue::String(value))
                }
                SetParam::LinkMembers(where_params) => (
                    "members".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::group_member::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkMembers(where_params) => (
                    "members".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::group_member::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::image::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::image::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkAlbums(where_params) => (
                    "albums".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::album::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkAlbums(where_params) => (
                    "albums".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::album::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        Name(Direction),
        DisplayName(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    "displayName".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Name(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
                Self::Name(cursor) => ("name".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameMode(QueryMode),
        NameNot(String),
        DisplayNameEquals(String),
        DisplayNameInVec(Vec<String>),
        DisplayNameNotInVec(Vec<String>),
        DisplayNameLt(String),
        DisplayNameLte(String),
        DisplayNameGt(String),
        DisplayNameGte(String),
        DisplayNameContains(String),
        DisplayNameStartsWith(String),
        DisplayNameEndsWith(String),
        DisplayNameMode(QueryMode),
        DisplayNameNot(String),
        MembersSome(Vec<super::group_member::WhereParam>),
        MembersEvery(Vec<super::group_member::WhereParam>),
        MembersNone(Vec<super::group_member::WhereParam>),
        ImagesSome(Vec<super::image::WhereParam>),
        ImagesEvery(Vec<super::image::WhereParam>),
        ImagesNone(Vec<super::image::WhereParam>),
        AlbumsSome(Vec<super::album::WhereParam>),
        AlbumsEvery(Vec<super::album::WhereParam>),
        AlbumsNone(Vec<super::album::WhereParam>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<String>),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NameEquals(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameLte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameGte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameContains(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameStartsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameEndsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NameMode(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NameNot(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameEquals(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameInVec(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DisplayNameNotInVec(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DisplayNameLt(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameLte(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameGt(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameGte(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameContains(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameStartsWith(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameEndsWith(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameMode(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DisplayNameNot(value) => (
                    "displayName".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MembersSome(value) => (
                    "members".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::MembersEvery(value) => (
                    "members".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::MembersNone(value) => (
                    "members".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesSome(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesEvery(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesNone(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsSome(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsEvery(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsNone(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
        NameEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::NameEquals(value) => Self::NameEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            name: name::Set,
            display_name: display_name::Set,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(name.into());
            _params.push(display_name.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Group", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Group", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Group", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Group", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (id::Set, name::Set, display_name::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, name, display_name, mut _params) = _create;
            _params.push(id.into());
            _params.push(name.into());
            _params.push(display_name.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Group", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod group_member {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: GroupMemberRole) -> T {
            Set(value).into()
        }
        pub fn equals(value: GroupMemberRole) -> WhereParam {
            WhereParam::RoleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub struct Set(GroupMemberRole);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRole(value.0)
            }
        }
    }
    pub mod group {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIs(value)
        }
        pub fn is_not(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIsNot(value)
        }
        pub struct Fetch {
            args: group::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Group(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: group::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: group::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkGroup
        }
        pub struct Link(group::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkGroup(value.0)
            }
        }
    }
    pub mod group_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GroupIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::GroupId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GroupIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GroupIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GroupIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GroupIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GroupIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GroupIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GroupIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::GroupIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GroupIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGroupId(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkUser
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod invited_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::InvitedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::InvitedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::InvitedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::InvitedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetInvitedAt(value.0)
            }
        }
    }
    pub fn group_id_user_id<T: From<UniqueWhereParam>>(group_id: String, user_id: String) -> T {
        UniqueWhereParam::GroupIdUserIdEquals(group_id, user_id).into()
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "role", "groupId", "userId", "invitedAt"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "role")]
        pub role: GroupMemberRole,
        #[serde(rename = "group")]
        pub group: Option<Box<super::group::Data>>,
        #[serde(rename = "groupId")]
        pub group_id: String,
        #[serde(rename = "user")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
        #[serde(rename = "invitedAt")]
        pub invited_at: chrono::DateTime<chrono::FixedOffset>,
    }
    impl Data {
        pub fn group(&self) -> Result<&super::group::Data, &'static str> {
            self.group
                .as_ref()
                .ok_or("Attempted to access 'group' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
    }
    pub enum WithParam {
        Group(super::group::UniqueArgs),
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Group(args) => {
                    let mut selections = super::group::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("group");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetRole(GroupMemberRole),
        LinkGroup(super::group::UniqueWhereParam),
        UnlinkGroup,
        SetGroupId(String),
        LinkUser(super::user::UniqueWhereParam),
        UnlinkUser,
        SetUserId(String),
        SetInvitedAt(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetRole(value) => {
                    ("role".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::LinkGroup(where_param) => (
                    "group".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::group::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkGroup => (
                    "group".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetGroupId(value) => ("groupId".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkUser => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
                SetParam::SetInvitedAt(value) => {
                    ("invitedAt".to_string(), PrismaValue::DateTime(value))
                }
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Role(Direction),
        GroupId(Direction),
        UserId(Direction),
        InvitedAt(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::Role(direction) => (
                    "role".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::GroupId(direction) => (
                    "groupId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::InvitedAt(direction) => (
                    "invitedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GroupIdUserIdEquals(String, String),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        RoleEquals(GroupMemberRole),
        GroupIs(Vec<super::group::WhereParam>),
        GroupIsNot(Vec<super::group::WhereParam>),
        GroupIdEquals(String),
        GroupIdInVec(Vec<String>),
        GroupIdNotInVec(Vec<String>),
        GroupIdLt(String),
        GroupIdLte(String),
        GroupIdGt(String),
        GroupIdGte(String),
        GroupIdContains(String),
        GroupIdStartsWith(String),
        GroupIdEndsWith(String),
        GroupIdMode(QueryMode),
        GroupIdNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
        InvitedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        InvitedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        InvitedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        InvitedAtLt(chrono::DateTime<chrono::FixedOffset>),
        InvitedAtLte(chrono::DateTime<chrono::FixedOffset>),
        InvitedAtGt(chrono::DateTime<chrono::FixedOffset>),
        InvitedAtGte(chrono::DateTime<chrono::FixedOffset>),
        InvitedAtNot(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::GroupIdUserIdEquals(group_id, user_id) => (
                    "groupId_userId".to_string(),
                    SerializedWhereValue::Object(vec![
                        ("groupId".to_string(), PrismaValue::String(group_id)),
                        ("userId".to_string(), PrismaValue::String(user_id)),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RoleEquals(value) => (
                    "role".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::GroupIs(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIsNot(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIdEquals(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdNotInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdLt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdLte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdContains(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdStartsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdEndsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdMode(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::GroupIdNot(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::InvitedAtEquals(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::InvitedAtInVec(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvitedAtNotInVec(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvitedAtLt(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::InvitedAtLte(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::InvitedAtGt(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::InvitedAtGte(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::InvitedAtNot(value) => (
                    "invitedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
        GroupIdUserIdEquals(String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::GroupIdUserIdEquals(group_id, user_id) => {
                    Self::GroupIdUserIdEquals(group_id, user_id)
                }
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            group: group::Link,
            user: user::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(group.into());
            _params.push(user.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("GroupMember", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("GroupMember", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("GroupMember", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("GroupMember", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (id::Set, group::Link, user::Link, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, group, user, mut _params) = _create;
            _params.push(id.into());
            _params.push(group.into());
            _params.push(user.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("GroupMember", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UsernameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Username(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UsernameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UsernameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UsernameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UsernameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UsernameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UsernameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UsernameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UsernameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UsernameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUsername(value.0)
            }
        }
    }
    pub mod nickname {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NicknameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Nickname(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NicknameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NicknameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NicknameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NicknameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NicknameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NicknameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NicknameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NicknameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NicknameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NicknameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NicknameNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNickname(value.0)
            }
        }
    }
    pub mod bio {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::BioEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Bio(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BioInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BioNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::BioLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::BioLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::BioGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::BioGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::BioContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::BioStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::BioEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::BioMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::BioNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBio(value.0)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: UserRole) -> T {
            Set(value).into()
        }
        pub fn equals(value: UserRole) -> WhereParam {
            WhereParam::RoleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub struct Set(UserRole);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRole(value.0)
            }
        }
    }
    pub mod permissions {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::PermissionsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Permissions(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PermissionsInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PermissionsNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::PermissionsLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::PermissionsLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::PermissionsGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::PermissionsGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::PermissionsNot(value)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPermissions(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPermissions(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPermissions(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePermissions(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPermissions(value.0)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Email(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EmailMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
    }
    pub mod hashed_password {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::HashedPasswordEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HashedPassword(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedPasswordInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedPasswordNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HashedPasswordLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HashedPasswordLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HashedPasswordGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HashedPasswordGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HashedPasswordContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HashedPasswordStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HashedPasswordEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::HashedPasswordMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HashedPasswordNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHashedPassword(value.0)
            }
        }
    }
    pub mod avatar_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AvatarUrlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AvatarUrl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AvatarUrlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AvatarUrlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AvatarUrlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AvatarUrlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AvatarUrlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AvatarUrlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AvatarUrlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AvatarUrlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AvatarUrlEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AvatarUrlMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AvatarUrlNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAvatarUrl(value.0)
            }
        }
    }
    pub mod avatar_source_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AvatarSourceIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AvatarSourceId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AvatarSourceIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AvatarSourceIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AvatarSourceIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AvatarSourceIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAvatarSourceId(value.0)
            }
        }
    }
    pub mod banner_ext {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::BannerExtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::BannerExt(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BannerExtInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BannerExtNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::BannerExtLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::BannerExtLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::BannerExtGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::BannerExtGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::BannerExtContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::BannerExtStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::BannerExtEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::BannerExtMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::BannerExtNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBannerExt(value.0)
            }
        }
    }
    pub mod badges {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<UserBadge>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<UserBadge>) -> WhereParam {
            WhereParam::BadgesEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Badges(direction)
        }
        pub struct Set(Vec<UserBadge>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBadges(value.0)
            }
        }
    }
    pub mod lock_status {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: LockingStatus) -> T {
            Set(value).into()
        }
        pub fn equals(value: LockingStatus) -> WhereParam {
            WhereParam::LockStatusEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::LockStatus(direction)
        }
        pub struct Set(LockingStatus);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLockStatus(value.0)
            }
        }
    }
    pub mod reports {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportsSome(value)
        }
        pub fn every(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportsEvery(value)
        }
        pub fn none(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportsNone(value)
        }
        pub struct Fetch {
            args: report::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<report::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: report::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<report::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Reports(fetch.args)
            }
        }
        pub fn fetch(params: Vec<report::WhereParam>) -> Fetch {
            Fetch {
                args: report::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<report::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<report::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkReports(params)
        }
        pub struct Link(Vec<report::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkReports(value.0)
            }
        }
    }
    pub mod created_reports {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::CreatedReportsSome(value)
        }
        pub fn every(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::CreatedReportsEvery(value)
        }
        pub fn none(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::CreatedReportsNone(value)
        }
        pub struct Fetch {
            args: report::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<report::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: report::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<report::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::CreatedReports(fetch.args)
            }
        }
        pub fn fetch(params: Vec<report::WhereParam>) -> Fetch {
            Fetch {
                args: report::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<report::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<report::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkCreatedReports(params)
        }
        pub struct Link(Vec<report::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkCreatedReports(value.0)
            }
        }
    }
    pub mod memberships {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembershipsSome(value)
        }
        pub fn every(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembershipsEvery(value)
        }
        pub fn none(value: Vec<group_member::WhereParam>) -> WhereParam {
            WhereParam::MembershipsNone(value)
        }
        pub struct Fetch {
            args: group_member::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group_member::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: group_member::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<group_member::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Memberships(fetch.args)
            }
        }
        pub fn fetch(params: Vec<group_member::WhereParam>) -> Fetch {
            Fetch {
                args: group_member::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<group_member::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<group_member::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkMemberships(params)
        }
        pub struct Link(Vec<group_member::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkMemberships(value.0)
            }
        }
    }
    pub mod connections {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user_connection::WhereParam>) -> WhereParam {
            WhereParam::ConnectionsSome(value)
        }
        pub fn every(value: Vec<user_connection::WhereParam>) -> WhereParam {
            WhereParam::ConnectionsEvery(value)
        }
        pub fn none(value: Vec<user_connection::WhereParam>) -> WhereParam {
            WhereParam::ConnectionsNone(value)
        }
        pub struct Fetch {
            args: user_connection::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_connection::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user_connection::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<user_connection::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Connections(fetch.args)
            }
        }
        pub fn fetch(params: Vec<user_connection::WhereParam>) -> Fetch {
            Fetch {
                args: user_connection::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<user_connection::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user_connection::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkConnections(params)
        }
        pub struct Link(Vec<user_connection::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkConnections(value.0)
            }
        }
    }
    pub mod premium_features {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<PremiumFeature>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<PremiumFeature>) -> WhereParam {
            WhereParam::PremiumFeaturesEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PremiumFeatures(direction)
        }
        pub struct Set(Vec<PremiumFeature>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPremiumFeatures(value.0)
            }
        }
    }
    pub mod tokens {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<token::WhereParam>) -> WhereParam {
            WhereParam::TokensSome(value)
        }
        pub fn every(value: Vec<token::WhereParam>) -> WhereParam {
            WhereParam::TokensEvery(value)
        }
        pub fn none(value: Vec<token::WhereParam>) -> WhereParam {
            WhereParam::TokensNone(value)
        }
        pub struct Fetch {
            args: token::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<token::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: token::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<token::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Tokens(fetch.args)
            }
        }
        pub fn fetch(params: Vec<token::WhereParam>) -> Fetch {
            Fetch {
                args: token::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<token::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<token::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkTokens(params)
        }
        pub struct Link(Vec<token::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkTokens(value.0)
            }
        }
    }
    pub mod sessions {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<session::WhereParam>) -> WhereParam {
            WhereParam::SessionsSome(value)
        }
        pub fn every(value: Vec<session::WhereParam>) -> WhereParam {
            WhereParam::SessionsEvery(value)
        }
        pub fn none(value: Vec<session::WhereParam>) -> WhereParam {
            WhereParam::SessionsNone(value)
        }
        pub struct Fetch {
            args: session::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<session::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: session::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<session::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Sessions(fetch.args)
            }
        }
        pub fn fetch(params: Vec<session::WhereParam>) -> Fetch {
            Fetch {
                args: session::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<session::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<session::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkSessions(params)
        }
        pub struct Link(Vec<session::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkSessions(value.0)
            }
        }
    }
    pub mod albums {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsSome(value)
        }
        pub fn every(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsEvery(value)
        }
        pub fn none(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumsNone(value)
        }
        pub struct Fetch {
            args: album::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: album::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<album::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Albums(fetch.args)
            }
        }
        pub fn fetch(params: Vec<album::WhereParam>) -> Fetch {
            Fetch {
                args: album::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<album::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<album::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkAlbums(params)
        }
        pub struct Link(Vec<album::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAlbums(value.0)
            }
        }
    }
    pub mod images {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesSome(value)
        }
        pub fn every(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesEvery(value)
        }
        pub fn none(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesNone(value)
        }
        pub struct Fetch {
            args: image::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: image::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<image::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Images(fetch.args)
            }
        }
        pub fn fetch(params: Vec<image::WhereParam>) -> Fetch {
            Fetch {
                args: image::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<image::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<image::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkImages(params)
        }
        pub struct Link(Vec<image::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkImages(value.0)
            }
        }
    }
    pub mod groups {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupsSome(value)
        }
        pub fn every(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupsEvery(value)
        }
        pub fn none(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupsNone(value)
        }
        pub struct Fetch {
            args: group::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: group::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<group::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Groups(fetch.args)
            }
        }
        pub fn fetch(params: Vec<group::WhereParam>) -> Fetch {
            Fetch {
                args: group::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<group::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<group::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkGroups(params)
        }
        pub struct Link(Vec<group::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkGroups(value.0)
            }
        }
    }
    pub mod notifications {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<notification::WhereParam>) -> WhereParam {
            WhereParam::NotificationsSome(value)
        }
        pub fn every(value: Vec<notification::WhereParam>) -> WhereParam {
            WhereParam::NotificationsEvery(value)
        }
        pub fn none(value: Vec<notification::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNone(value)
        }
        pub struct Fetch {
            args: notification::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<notification::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: notification::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<notification::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Notifications(fetch.args)
            }
        }
        pub fn fetch(params: Vec<notification::WhereParam>) -> Fetch {
            Fetch {
                args: notification::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<notification::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<notification::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkNotifications(params)
        }
        pub struct Link(Vec<notification::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkNotifications(value.0)
            }
        }
    }
    pub mod moderator_notifications {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<moderator_notifications::WhereParam>) -> WhereParam {
            WhereParam::ModeratorNotificationsSome(value)
        }
        pub fn every(value: Vec<moderator_notifications::WhereParam>) -> WhereParam {
            WhereParam::ModeratorNotificationsEvery(value)
        }
        pub fn none(value: Vec<moderator_notifications::WhereParam>) -> WhereParam {
            WhereParam::ModeratorNotificationsNone(value)
        }
        pub struct Fetch {
            args: moderator_notifications::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<moderator_notifications::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: moderator_notifications::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<moderator_notifications::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::ModeratorNotifications(fetch.args)
            }
        }
        pub fn fetch(params: Vec<moderator_notifications::WhereParam>) -> Fetch {
            Fetch {
                args: moderator_notifications::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<moderator_notifications::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<moderator_notifications::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkModeratorNotifications(params)
        }
        pub struct Link(Vec<moderator_notifications::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkModeratorNotifications(value.0)
            }
        }
    }
    pub mod favourite_users {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FavouriteUsersSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FavouriteUsersEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FavouriteUsersNone(value)
        }
        pub struct Fetch {
            args: user::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<user::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::FavouriteUsers(fetch.args)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch {
                args: user::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<user::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkFavouriteUsers(params)
        }
        pub struct Link(Vec<user::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkFavouriteUsers(value.0)
            }
        }
    }
    pub mod favourite_albums {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::FavouriteAlbumsSome(value)
        }
        pub fn every(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::FavouriteAlbumsEvery(value)
        }
        pub fn none(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::FavouriteAlbumsNone(value)
        }
        pub struct Fetch {
            args: album::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: album::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<album::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::FavouriteAlbums(fetch.args)
            }
        }
        pub fn fetch(params: Vec<album::WhereParam>) -> Fetch {
            Fetch {
                args: album::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<album::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<album::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkFavouriteAlbums(params)
        }
        pub struct Link(Vec<album::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkFavouriteAlbums(value.0)
            }
        }
    }
    pub mod favourite_images {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::FavouriteImagesSome(value)
        }
        pub fn every(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::FavouriteImagesEvery(value)
        }
        pub fn none(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::FavouriteImagesNone(value)
        }
        pub struct Fetch {
            args: image::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: image::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<image::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::FavouriteImages(fetch.args)
            }
        }
        pub fn fetch(params: Vec<image::WhereParam>) -> Fetch {
            Fetch {
                args: image::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<image::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<image::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkFavouriteImages(params)
        }
        pub struct Link(Vec<image::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkFavouriteImages(value.0)
            }
        }
    }
    pub mod user_favourites {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesNone(value)
        }
        pub struct Fetch {
            args: user::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<user::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::UserFavourites(fetch.args)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch {
                args: user::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<user::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkUserFavourites(params)
        }
        pub struct Link(Vec<user::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUserFavourites(value.0)
            }
        }
    }
    pub mod user_favourite_ids {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserFavouriteIds(direction)
        }
        pub fn has(value: String) -> WhereParam {
            WhereParam::UserFavouriteIdsHas(value)
        }
        pub fn has_every(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasEvery(value)
        }
        pub fn has_some(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasSome(value)
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::UserFavouriteIdsIsEmpty(value)
        }
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushUserFavouriteIds(value)
        }
        pub struct Set(Vec<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserFavouriteIds(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "username",
            "nickname",
            "bio",
            "role",
            "permissions",
            "email",
            "hashedPassword",
            "avatarUrl",
            "avatarSourceId",
            "bannerExt",
            "badges",
            "lockStatus",
            "premiumFeatures",
            "userFavouriteIds",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "nickname")]
        pub nickname: Option<String>,
        #[serde(rename = "bio")]
        pub bio: Option<String>,
        #[serde(rename = "role")]
        pub role: UserRole,
        #[serde(rename = "permissions")]
        pub permissions: i32,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "hashedPassword")]
        pub hashed_password: Option<String>,
        #[serde(rename = "avatarUrl")]
        pub avatar_url: Option<String>,
        #[serde(rename = "avatarSourceId")]
        pub avatar_source_id: Option<String>,
        #[serde(rename = "bannerExt")]
        pub banner_ext: String,
        #[serde(rename = "badges")]
        pub badges: Vec<UserBadge>,
        #[serde(rename = "lockStatus")]
        pub lock_status: LockingStatus,
        #[serde(rename = "reports")]
        pub reports: Option<Vec<super::report::Data>>,
        #[serde(rename = "createdReports")]
        pub created_reports: Option<Vec<super::report::Data>>,
        #[serde(rename = "memberships")]
        pub memberships: Option<Vec<super::group_member::Data>>,
        #[serde(rename = "connections")]
        pub connections: Option<Vec<super::user_connection::Data>>,
        #[serde(rename = "premiumFeatures")]
        pub premium_features: Vec<PremiumFeature>,
        #[serde(rename = "tokens")]
        pub tokens: Option<Vec<super::token::Data>>,
        #[serde(rename = "sessions")]
        pub sessions: Option<Vec<super::session::Data>>,
        #[serde(rename = "albums")]
        pub albums: Option<Vec<super::album::Data>>,
        #[serde(rename = "images")]
        pub images: Option<Vec<super::image::Data>>,
        #[serde(rename = "groups")]
        pub groups: Option<Vec<super::group::Data>>,
        #[serde(rename = "notifications")]
        pub notifications: Option<Vec<super::notification::Data>>,
        #[serde(rename = "moderatorNotifications")]
        pub moderator_notifications: Option<Vec<super::moderator_notifications::Data>>,
        #[serde(rename = "favouriteUsers")]
        pub favourite_users: Option<Vec<super::user::Data>>,
        #[serde(rename = "favouriteAlbums")]
        pub favourite_albums: Option<Vec<super::album::Data>>,
        #[serde(rename = "favouriteImages")]
        pub favourite_images: Option<Vec<super::image::Data>>,
        #[serde(rename = "userFavourites")]
        pub user_favourites: Option<Vec<super::user::Data>>,
        #[serde(rename = "userFavouriteIds")]
        pub user_favourite_ids: Vec<String>,
    }
    impl Data {
        pub fn reports(&self) -> Result<&Vec<super::report::Data>, &'static str> {
            self.reports.as_ref().ok_or(
                "Attempted to access 'reports' but did not fetch it using the .with() syntax",
            )
        }
        pub fn created_reports(&self) -> Result<&Vec<super::report::Data>, &'static str> {
            self . created_reports . as_ref () . ok_or ("Attempted to access 'created_reports' but did not fetch it using the .with() syntax")
        }
        pub fn memberships(&self) -> Result<&Vec<super::group_member::Data>, &'static str> {
            self.memberships.as_ref().ok_or(
                "Attempted to access 'memberships' but did not fetch it using the .with() syntax",
            )
        }
        pub fn connections(&self) -> Result<&Vec<super::user_connection::Data>, &'static str> {
            self.connections.as_ref().ok_or(
                "Attempted to access 'connections' but did not fetch it using the .with() syntax",
            )
        }
        pub fn tokens(&self) -> Result<&Vec<super::token::Data>, &'static str> {
            self.tokens
                .as_ref()
                .ok_or("Attempted to access 'tokens' but did not fetch it using the .with() syntax")
        }
        pub fn sessions(&self) -> Result<&Vec<super::session::Data>, &'static str> {
            self.sessions.as_ref().ok_or(
                "Attempted to access 'sessions' but did not fetch it using the .with() syntax",
            )
        }
        pub fn albums(&self) -> Result<&Vec<super::album::Data>, &'static str> {
            self.albums
                .as_ref()
                .ok_or("Attempted to access 'albums' but did not fetch it using the .with() syntax")
        }
        pub fn images(&self) -> Result<&Vec<super::image::Data>, &'static str> {
            self.images
                .as_ref()
                .ok_or("Attempted to access 'images' but did not fetch it using the .with() syntax")
        }
        pub fn groups(&self) -> Result<&Vec<super::group::Data>, &'static str> {
            self.groups
                .as_ref()
                .ok_or("Attempted to access 'groups' but did not fetch it using the .with() syntax")
        }
        pub fn notifications(&self) -> Result<&Vec<super::notification::Data>, &'static str> {
            self.notifications.as_ref().ok_or(
                "Attempted to access 'notifications' but did not fetch it using the .with() syntax",
            )
        }
        pub fn moderator_notifications(
            &self,
        ) -> Result<&Vec<super::moderator_notifications::Data>, &'static str> {
            self . moderator_notifications . as_ref () . ok_or ("Attempted to access 'moderator_notifications' but did not fetch it using the .with() syntax")
        }
        pub fn favourite_users(&self) -> Result<&Vec<super::user::Data>, &'static str> {
            self . favourite_users . as_ref () . ok_or ("Attempted to access 'favourite_users' but did not fetch it using the .with() syntax")
        }
        pub fn favourite_albums(&self) -> Result<&Vec<super::album::Data>, &'static str> {
            self . favourite_albums . as_ref () . ok_or ("Attempted to access 'favourite_albums' but did not fetch it using the .with() syntax")
        }
        pub fn favourite_images(&self) -> Result<&Vec<super::image::Data>, &'static str> {
            self . favourite_images . as_ref () . ok_or ("Attempted to access 'favourite_images' but did not fetch it using the .with() syntax")
        }
        pub fn user_favourites(&self) -> Result<&Vec<super::user::Data>, &'static str> {
            self . user_favourites . as_ref () . ok_or ("Attempted to access 'user_favourites' but did not fetch it using the .with() syntax")
        }
    }
    pub enum WithParam {
        Reports(super::report::ManyArgs),
        CreatedReports(super::report::ManyArgs),
        Memberships(super::group_member::ManyArgs),
        Connections(super::user_connection::ManyArgs),
        Tokens(super::token::ManyArgs),
        Sessions(super::session::ManyArgs),
        Albums(super::album::ManyArgs),
        Images(super::image::ManyArgs),
        Groups(super::group::ManyArgs),
        Notifications(super::notification::ManyArgs),
        ModeratorNotifications(super::moderator_notifications::ManyArgs),
        FavouriteUsers(super::user::ManyArgs),
        FavouriteAlbums(super::album::ManyArgs),
        FavouriteImages(super::image::ManyArgs),
        UserFavourites(super::user::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Reports(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::report::_outputs());
                    let mut builder = Selection::builder("reports");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::CreatedReports(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::report::_outputs());
                    let mut builder = Selection::builder("createdReports");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Memberships(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::group_member::_outputs());
                    let mut builder = Selection::builder("memberships");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Connections(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user_connection::_outputs());
                    let mut builder = Selection::builder("connections");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Tokens(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::token::_outputs());
                    let mut builder = Selection::builder("tokens");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Sessions(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::session::_outputs());
                    let mut builder = Selection::builder("sessions");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Albums(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::album::_outputs());
                    let mut builder = Selection::builder("albums");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Images(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::image::_outputs());
                    let mut builder = Selection::builder("images");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Groups(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::group::_outputs());
                    let mut builder = Selection::builder("groups");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Notifications(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::notification::_outputs());
                    let mut builder = Selection::builder("notifications");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::ModeratorNotifications(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::moderator_notifications::_outputs());
                    let mut builder = Selection::builder("moderatorNotifications");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::FavouriteUsers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user::_outputs());
                    let mut builder = Selection::builder("favouriteUsers");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::FavouriteAlbums(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::album::_outputs());
                    let mut builder = Selection::builder("favouriteAlbums");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::FavouriteImages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::image::_outputs());
                    let mut builder = Selection::builder("favouriteImages");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::UserFavourites(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user::_outputs());
                    let mut builder = Selection::builder("userFavourites");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUsername(String),
        SetNickname(Option<String>),
        SetBio(Option<String>),
        SetRole(UserRole),
        SetPermissions(i32),
        IncrementPermissions(i32),
        DecrementPermissions(i32),
        MultiplyPermissions(i32),
        DividePermissions(i32),
        SetEmail(String),
        SetHashedPassword(Option<String>),
        SetAvatarUrl(Option<String>),
        SetAvatarSourceId(Option<String>),
        SetBannerExt(String),
        SetBadges(Vec<UserBadge>),
        SetLockStatus(LockingStatus),
        LinkReports(Vec<super::report::UniqueWhereParam>),
        UnlinkReports(Vec<super::report::UniqueWhereParam>),
        LinkCreatedReports(Vec<super::report::UniqueWhereParam>),
        UnlinkCreatedReports(Vec<super::report::UniqueWhereParam>),
        LinkMemberships(Vec<super::group_member::UniqueWhereParam>),
        UnlinkMemberships(Vec<super::group_member::UniqueWhereParam>),
        LinkConnections(Vec<super::user_connection::UniqueWhereParam>),
        UnlinkConnections(Vec<super::user_connection::UniqueWhereParam>),
        SetPremiumFeatures(Vec<PremiumFeature>),
        LinkTokens(Vec<super::token::UniqueWhereParam>),
        UnlinkTokens(Vec<super::token::UniqueWhereParam>),
        LinkSessions(Vec<super::session::UniqueWhereParam>),
        UnlinkSessions(Vec<super::session::UniqueWhereParam>),
        LinkAlbums(Vec<super::album::UniqueWhereParam>),
        UnlinkAlbums(Vec<super::album::UniqueWhereParam>),
        LinkImages(Vec<super::image::UniqueWhereParam>),
        UnlinkImages(Vec<super::image::UniqueWhereParam>),
        LinkGroups(Vec<super::group::UniqueWhereParam>),
        UnlinkGroups(Vec<super::group::UniqueWhereParam>),
        LinkNotifications(Vec<super::notification::UniqueWhereParam>),
        UnlinkNotifications(Vec<super::notification::UniqueWhereParam>),
        LinkModeratorNotifications(Vec<super::moderator_notifications::UniqueWhereParam>),
        UnlinkModeratorNotifications(Vec<super::moderator_notifications::UniqueWhereParam>),
        LinkFavouriteUsers(Vec<super::user::UniqueWhereParam>),
        UnlinkFavouriteUsers(Vec<super::user::UniqueWhereParam>),
        LinkFavouriteAlbums(Vec<super::album::UniqueWhereParam>),
        UnlinkFavouriteAlbums(Vec<super::album::UniqueWhereParam>),
        LinkFavouriteImages(Vec<super::image::UniqueWhereParam>),
        UnlinkFavouriteImages(Vec<super::image::UniqueWhereParam>),
        LinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        UnlinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        SetUserFavouriteIds(Vec<String>),
        PushUserFavouriteIds(Vec<String>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUsername(value) => {
                    ("username".to_string(), PrismaValue::String(value))
                }
                SetParam::SetNickname(value) => (
                    "nickname".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetBio(value) => (
                    "bio".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetRole(value) => {
                    ("role".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::SetPermissions(value) => {
                    ("permissions".to_string(), PrismaValue::Int(value as i64))
                }
                SetParam::IncrementPermissions(value) => (
                    "permissions".to_string(),
                    PrismaValue::Object(vec![(
                        "increment".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPermissions(value) => (
                    "permissions".to_string(),
                    PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPermissions(value) => (
                    "permissions".to_string(),
                    PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePermissions(value) => (
                    "permissions".to_string(),
                    PrismaValue::Object(vec![(
                        "divide".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetEmail(value) => ("email".to_string(), PrismaValue::String(value)),
                SetParam::SetHashedPassword(value) => (
                    "hashedPassword".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetAvatarUrl(value) => (
                    "avatarUrl".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetAvatarSourceId(value) => (
                    "avatarSourceId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetBannerExt(value) => {
                    ("bannerExt".to_string(), PrismaValue::String(value))
                }
                SetParam::SetBadges(value) => (
                    "badges".to_string(),
                    PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Enum(v.to_string()))
                            .collect(),
                    ),
                ),
                SetParam::SetLockStatus(value) => (
                    "lockStatus".to_string(),
                    PrismaValue::Enum(value.to_string()),
                ),
                SetParam::LinkReports(where_params) => (
                    "reports".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::report::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkReports(where_params) => (
                    "reports".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::report::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkCreatedReports(where_params) => (
                    "createdReports".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::report::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkCreatedReports(where_params) => (
                    "createdReports".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::report::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkMemberships(where_params) => (
                    "memberships".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::group_member::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkMemberships(where_params) => (
                    "memberships".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::group_member::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkConnections(where_params) => (
                    "connections".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_connection::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkConnections(where_params) => (
                    "connections".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::user_connection::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::SetPremiumFeatures(value) => (
                    "premiumFeatures".to_string(),
                    PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Enum(v.to_string()))
                            .collect(),
                    ),
                ),
                SetParam::LinkTokens(where_params) => (
                    "tokens".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::token::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkTokens(where_params) => (
                    "tokens".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::token::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkSessions(where_params) => (
                    "sessions".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::session::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkSessions(where_params) => (
                    "sessions".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::session::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkAlbums(where_params) => (
                    "albums".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::album::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkAlbums(where_params) => (
                    "albums".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::album::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::image::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::image::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkGroups(where_params) => (
                    "groups".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::group::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkGroups(where_params) => (
                    "groups".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::group::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkNotifications(where_params) => (
                    "notifications".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::notification::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkNotifications(where_params) => (
                    "notifications".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::notification::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkModeratorNotifications(where_params) => (
                    "moderatorNotifications".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::moderator_notifications::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkModeratorNotifications(where_params) => (
                    "moderatorNotifications".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::moderator_notifications::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkFavouriteUsers(where_params) => (
                    "favouriteUsers".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkFavouriteUsers(where_params) => (
                    "favouriteUsers".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::user::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkFavouriteAlbums(where_params) => (
                    "favouriteAlbums".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::album::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkFavouriteAlbums(where_params) => (
                    "favouriteAlbums".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::album::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkFavouriteImages(where_params) => (
                    "favouriteImages".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::image::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkFavouriteImages(where_params) => (
                    "favouriteImages".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::image::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::user::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
                ),
                SetParam::PushUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::Object(vec![(
                        "push".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        Username(Direction),
        Nickname(Direction),
        Bio(Direction),
        Role(Direction),
        Permissions(Direction),
        Email(Direction),
        HashedPassword(Direction),
        AvatarUrl(Direction),
        AvatarSourceId(Direction),
        BannerExt(Direction),
        Badges(Direction),
        LockStatus(Direction),
        PremiumFeatures(Direction),
        UserFavouriteIds(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Username(direction) => (
                    "username".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Nickname(direction) => (
                    "nickname".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Bio(direction) => (
                    "bio".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    "role".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Permissions(direction) => (
                    "permissions".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::HashedPassword(direction) => (
                    "hashedPassword".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AvatarUrl(direction) => (
                    "avatarUrl".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AvatarSourceId(direction) => (
                    "avatarSourceId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::BannerExt(direction) => (
                    "bannerExt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Badges(direction) => (
                    "badges".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::LockStatus(direction) => (
                    "lockStatus".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::PremiumFeatures(direction) => (
                    "premiumFeatures".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserFavouriteIds(direction) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Username(String),
        Email(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
                Self::Username(cursor) => ("username".to_string(), PrismaValue::String(cursor)),
                Self::Email(cursor) => ("email".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UsernameEquals(String),
        UsernameInVec(Vec<String>),
        UsernameNotInVec(Vec<String>),
        UsernameLt(String),
        UsernameLte(String),
        UsernameGt(String),
        UsernameGte(String),
        UsernameContains(String),
        UsernameStartsWith(String),
        UsernameEndsWith(String),
        UsernameMode(QueryMode),
        UsernameNot(String),
        NicknameEquals(Option<String>),
        NicknameInVec(Vec<String>),
        NicknameNotInVec(Vec<String>),
        NicknameLt(String),
        NicknameLte(String),
        NicknameGt(String),
        NicknameGte(String),
        NicknameContains(String),
        NicknameStartsWith(String),
        NicknameEndsWith(String),
        NicknameMode(QueryMode),
        NicknameNot(String),
        BioEquals(Option<String>),
        BioInVec(Vec<String>),
        BioNotInVec(Vec<String>),
        BioLt(String),
        BioLte(String),
        BioGt(String),
        BioGte(String),
        BioContains(String),
        BioStartsWith(String),
        BioEndsWith(String),
        BioMode(QueryMode),
        BioNot(String),
        RoleEquals(UserRole),
        PermissionsEquals(i32),
        PermissionsInVec(Vec<i32>),
        PermissionsNotInVec(Vec<i32>),
        PermissionsLt(i32),
        PermissionsLte(i32),
        PermissionsGt(i32),
        PermissionsGte(i32),
        PermissionsNot(i32),
        EmailEquals(String),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailMode(QueryMode),
        EmailNot(String),
        HashedPasswordEquals(Option<String>),
        HashedPasswordInVec(Vec<String>),
        HashedPasswordNotInVec(Vec<String>),
        HashedPasswordLt(String),
        HashedPasswordLte(String),
        HashedPasswordGt(String),
        HashedPasswordGte(String),
        HashedPasswordContains(String),
        HashedPasswordStartsWith(String),
        HashedPasswordEndsWith(String),
        HashedPasswordMode(QueryMode),
        HashedPasswordNot(String),
        AvatarUrlEquals(Option<String>),
        AvatarUrlInVec(Vec<String>),
        AvatarUrlNotInVec(Vec<String>),
        AvatarUrlLt(String),
        AvatarUrlLte(String),
        AvatarUrlGt(String),
        AvatarUrlGte(String),
        AvatarUrlContains(String),
        AvatarUrlStartsWith(String),
        AvatarUrlEndsWith(String),
        AvatarUrlMode(QueryMode),
        AvatarUrlNot(String),
        AvatarSourceIdEquals(Option<String>),
        AvatarSourceIdInVec(Vec<String>),
        AvatarSourceIdNotInVec(Vec<String>),
        AvatarSourceIdLt(String),
        AvatarSourceIdLte(String),
        AvatarSourceIdGt(String),
        AvatarSourceIdGte(String),
        AvatarSourceIdContains(String),
        AvatarSourceIdStartsWith(String),
        AvatarSourceIdEndsWith(String),
        AvatarSourceIdMode(QueryMode),
        AvatarSourceIdNot(String),
        BannerExtEquals(String),
        BannerExtInVec(Vec<String>),
        BannerExtNotInVec(Vec<String>),
        BannerExtLt(String),
        BannerExtLte(String),
        BannerExtGt(String),
        BannerExtGte(String),
        BannerExtContains(String),
        BannerExtStartsWith(String),
        BannerExtEndsWith(String),
        BannerExtMode(QueryMode),
        BannerExtNot(String),
        BadgesEquals(Vec<UserBadge>),
        LockStatusEquals(LockingStatus),
        ReportsSome(Vec<super::report::WhereParam>),
        ReportsEvery(Vec<super::report::WhereParam>),
        ReportsNone(Vec<super::report::WhereParam>),
        CreatedReportsSome(Vec<super::report::WhereParam>),
        CreatedReportsEvery(Vec<super::report::WhereParam>),
        CreatedReportsNone(Vec<super::report::WhereParam>),
        MembershipsSome(Vec<super::group_member::WhereParam>),
        MembershipsEvery(Vec<super::group_member::WhereParam>),
        MembershipsNone(Vec<super::group_member::WhereParam>),
        ConnectionsSome(Vec<super::user_connection::WhereParam>),
        ConnectionsEvery(Vec<super::user_connection::WhereParam>),
        ConnectionsNone(Vec<super::user_connection::WhereParam>),
        PremiumFeaturesEquals(Vec<PremiumFeature>),
        TokensSome(Vec<super::token::WhereParam>),
        TokensEvery(Vec<super::token::WhereParam>),
        TokensNone(Vec<super::token::WhereParam>),
        SessionsSome(Vec<super::session::WhereParam>),
        SessionsEvery(Vec<super::session::WhereParam>),
        SessionsNone(Vec<super::session::WhereParam>),
        AlbumsSome(Vec<super::album::WhereParam>),
        AlbumsEvery(Vec<super::album::WhereParam>),
        AlbumsNone(Vec<super::album::WhereParam>),
        ImagesSome(Vec<super::image::WhereParam>),
        ImagesEvery(Vec<super::image::WhereParam>),
        ImagesNone(Vec<super::image::WhereParam>),
        GroupsSome(Vec<super::group::WhereParam>),
        GroupsEvery(Vec<super::group::WhereParam>),
        GroupsNone(Vec<super::group::WhereParam>),
        NotificationsSome(Vec<super::notification::WhereParam>),
        NotificationsEvery(Vec<super::notification::WhereParam>),
        NotificationsNone(Vec<super::notification::WhereParam>),
        ModeratorNotificationsSome(Vec<super::moderator_notifications::WhereParam>),
        ModeratorNotificationsEvery(Vec<super::moderator_notifications::WhereParam>),
        ModeratorNotificationsNone(Vec<super::moderator_notifications::WhereParam>),
        FavouriteUsersSome(Vec<super::user::WhereParam>),
        FavouriteUsersEvery(Vec<super::user::WhereParam>),
        FavouriteUsersNone(Vec<super::user::WhereParam>),
        FavouriteAlbumsSome(Vec<super::album::WhereParam>),
        FavouriteAlbumsEvery(Vec<super::album::WhereParam>),
        FavouriteAlbumsNone(Vec<super::album::WhereParam>),
        FavouriteImagesSome(Vec<super::image::WhereParam>),
        FavouriteImagesEvery(Vec<super::image::WhereParam>),
        FavouriteImagesNone(Vec<super::image::WhereParam>),
        UserFavouritesSome(Vec<super::user::WhereParam>),
        UserFavouritesEvery(Vec<super::user::WhereParam>),
        UserFavouritesNone(Vec<super::user::WhereParam>),
        UserFavouriteIdsEquals(Vec<String>),
        UserFavouriteIdsHas(String),
        UserFavouriteIdsHasEvery(Vec<String>),
        UserFavouriteIdsHasSome(Vec<String>),
        UserFavouriteIdsIsEmpty(bool),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UsernameEquals(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameInVec(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UsernameNotInVec(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UsernameLt(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameLte(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameGt(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameGte(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameContains(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameStartsWith(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameEndsWith(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UsernameMode(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UsernameNot(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameEquals(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::NicknameInVec(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NicknameNotInVec(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::NicknameLt(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameLte(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameGt(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameGte(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameContains(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameStartsWith(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameEndsWith(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::NicknameMode(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NicknameNot(value) => (
                    "nickname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioEquals(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::BioInVec(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BioNotInVec(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BioLt(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioLte(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioGt(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioGte(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioContains(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioStartsWith(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioEndsWith(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BioMode(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::BioNot(value) => (
                    "bio".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RoleEquals(value) => (
                    "role".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::PermissionsEquals(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::PermissionsInVec(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::PermissionsNotInVec(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::PermissionsLt(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::PermissionsLte(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::PermissionsGt(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::PermissionsGte(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::PermissionsNot(value) => (
                    "permissions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::EmailEquals(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailInVec(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::EmailNotInVec(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::EmailLt(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailLte(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGt(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGte(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailContains(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailStartsWith(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEndsWith(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailMode(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EmailNot(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordEquals(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::HashedPasswordInVec(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedPasswordNotInVec(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedPasswordLt(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordLte(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordGt(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordGte(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordContains(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordStartsWith(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordEndsWith(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedPasswordMode(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::HashedPasswordNot(value) => (
                    "hashedPassword".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlEquals(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::AvatarUrlInVec(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AvatarUrlNotInVec(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AvatarUrlLt(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlLte(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlGt(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlGte(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlContains(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlStartsWith(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlEndsWith(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarUrlMode(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AvatarUrlNot(value) => (
                    "avatarUrl".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdEquals(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::AvatarSourceIdInVec(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AvatarSourceIdNotInVec(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AvatarSourceIdLt(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdLte(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdGt(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdGte(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdContains(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdStartsWith(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdEndsWith(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AvatarSourceIdMode(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AvatarSourceIdNot(value) => (
                    "avatarSourceId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtEquals(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtInVec(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BannerExtNotInVec(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BannerExtLt(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtLte(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtGt(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtGte(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtContains(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtStartsWith(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtEndsWith(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BannerExtMode(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::BannerExtNot(value) => (
                    "bannerExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BadgesEquals(value) => (
                    "badges".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Enum(v.to_string()))
                                .collect(),
                        ),
                    )]),
                ),
                Self::LockStatusEquals(value) => (
                    "lockStatus".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReportsSome(value) => (
                    "reports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportsEvery(value) => (
                    "reports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportsNone(value) => (
                    "reports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CreatedReportsSome(value) => (
                    "createdReports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CreatedReportsEvery(value) => (
                    "createdReports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CreatedReportsNone(value) => (
                    "createdReports".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::MembershipsSome(value) => (
                    "memberships".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::MembershipsEvery(value) => (
                    "memberships".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::MembershipsNone(value) => (
                    "memberships".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ConnectionsSome(value) => (
                    "connections".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ConnectionsEvery(value) => (
                    "connections".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ConnectionsNone(value) => (
                    "connections".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::PremiumFeaturesEquals(value) => (
                    "premiumFeatures".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Enum(v.to_string()))
                                .collect(),
                        ),
                    )]),
                ),
                Self::TokensSome(value) => (
                    "tokens".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::TokensEvery(value) => (
                    "tokens".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::TokensNone(value) => (
                    "tokens".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::SessionsSome(value) => (
                    "sessions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::SessionsEvery(value) => (
                    "sessions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::SessionsNone(value) => (
                    "sessions".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsSome(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsEvery(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumsNone(value) => (
                    "albums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesSome(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesEvery(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesNone(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupsSome(value) => (
                    "groups".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupsEvery(value) => (
                    "groups".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupsNone(value) => (
                    "groups".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::NotificationsSome(value) => (
                    "notifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::NotificationsEvery(value) => (
                    "notifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::NotificationsNone(value) => (
                    "notifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ModeratorNotificationsSome(value) => (
                    "moderatorNotifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ModeratorNotificationsEvery(value) => (
                    "moderatorNotifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ModeratorNotificationsNone(value) => (
                    "moderatorNotifications".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteUsersSome(value) => (
                    "favouriteUsers".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteUsersEvery(value) => (
                    "favouriteUsers".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteUsersNone(value) => (
                    "favouriteUsers".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteAlbumsSome(value) => (
                    "favouriteAlbums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteAlbumsEvery(value) => (
                    "favouriteAlbums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteAlbumsNone(value) => (
                    "favouriteAlbums".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteImagesSome(value) => (
                    "favouriteImages".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteImagesEvery(value) => (
                    "favouriteImages".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::FavouriteImagesNone(value) => (
                    "favouriteImages".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesSome(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesEvery(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesNone(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouriteIdsEquals(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHas(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserFavouriteIdsHasEvery(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasEvery".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHasSome(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasSome".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsIsEmpty(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isEmpty".to_string(),
                        PrismaValue::Boolean(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
        UsernameEquals(String),
        EmailEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::UsernameEquals(value) => Self::UsernameEquals(value),
                UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            username: username::Set,
            email: email::Set,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(username.into());
            _params.push(email.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (id::Set, username::Set, email::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, username, email, mut _params) = _create;
            _params.push(id.into());
            _params.push(username.into());
            _params.push(email.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod user_connection {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod conn_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: UserConnectionType) -> T {
            Set(value).into()
        }
        pub fn equals(value: UserConnectionType) -> WhereParam {
            WhereParam::ConnTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ConnType(direction)
        }
        pub struct Set(UserConnectionType);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConnType(value.0)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EmailEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EmailMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
    }
    pub mod handle {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::HandleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Handle(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HandleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HandleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HandleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HandleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HandleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HandleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HandleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HandleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HandleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::HandleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HandleNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHandle(value.0)
            }
        }
    }
    pub mod access_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AccessTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AccessToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccessTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccessTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccessTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccessTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccessTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccessTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccessTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccessTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccessTokenEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AccessTokenMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccessTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccessToken(value.0)
            }
        }
    }
    pub mod refresh_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RefreshTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::RefreshToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RefreshTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RefreshTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::RefreshTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::RefreshTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::RefreshTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::RefreshTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::RefreshTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::RefreshTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::RefreshTokenEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::RefreshTokenMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::RefreshTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRefreshToken(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtNot(value)
        }
        pub struct Set(Option<chrono::DateTime<chrono::FixedOffset>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkUser
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn email_conn_type<T: From<UniqueWhereParam>>(
        email: String,
        conn_type: UserConnectionType,
    ) -> T {
        UniqueWhereParam::EmailConnTypeEquals(email, conn_type).into()
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "conn_type",
            "email",
            "handle",
            "accessToken",
            "refreshToken",
            "createdAt",
            "updatedAt",
            "expiresAt",
            "userId",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "conn_type")]
        pub conn_type: UserConnectionType,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "handle")]
        pub handle: Option<String>,
        #[serde(rename = "accessToken")]
        pub access_token: Option<String>,
        #[serde(rename = "refreshToken")]
        pub refresh_token: Option<String>,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "expiresAt")]
        pub expires_at: Option<chrono::DateTime<chrono::FixedOffset>>,
        #[serde(rename = "user")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
    }
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetConnType(UserConnectionType),
        SetEmail(String),
        SetHandle(Option<String>),
        SetAccessToken(Option<String>),
        SetRefreshToken(Option<String>),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetExpiresAt(Option<chrono::DateTime<chrono::FixedOffset>>),
        LinkUser(super::user::UniqueWhereParam),
        UnlinkUser,
        SetUserId(String),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetConnType(value) => (
                    "conn_type".to_string(),
                    PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetEmail(value) => ("email".to_string(), PrismaValue::String(value)),
                SetParam::SetHandle(value) => (
                    "handle".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetAccessToken(value) => (
                    "accessToken".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetRefreshToken(value) => (
                    "refreshToken".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetExpiresAt(value) => (
                    "expiresAt".to_string(),
                    value
                        .map(|value| PrismaValue::DateTime(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkUser => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        ConnType(Direction),
        Email(Direction),
        Handle(Direction),
        AccessToken(Direction),
        RefreshToken(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        ExpiresAt(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::ConnType(direction) => (
                    "conn_type".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Handle(direction) => (
                    "handle".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AccessToken(direction) => (
                    "accessToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::RefreshToken(direction) => (
                    "refreshToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ExpiresAt(direction) => (
                    "expiresAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        EmailConnTypeEquals(String, UserConnectionType),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        ConnTypeEquals(UserConnectionType),
        EmailEquals(String),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailMode(QueryMode),
        EmailNot(String),
        HandleEquals(Option<String>),
        HandleInVec(Vec<String>),
        HandleNotInVec(Vec<String>),
        HandleLt(String),
        HandleLte(String),
        HandleGt(String),
        HandleGte(String),
        HandleContains(String),
        HandleStartsWith(String),
        HandleEndsWith(String),
        HandleMode(QueryMode),
        HandleNot(String),
        AccessTokenEquals(Option<String>),
        AccessTokenInVec(Vec<String>),
        AccessTokenNotInVec(Vec<String>),
        AccessTokenLt(String),
        AccessTokenLte(String),
        AccessTokenGt(String),
        AccessTokenGte(String),
        AccessTokenContains(String),
        AccessTokenStartsWith(String),
        AccessTokenEndsWith(String),
        AccessTokenMode(QueryMode),
        AccessTokenNot(String),
        RefreshTokenEquals(Option<String>),
        RefreshTokenInVec(Vec<String>),
        RefreshTokenNotInVec(Vec<String>),
        RefreshTokenLt(String),
        RefreshTokenLte(String),
        RefreshTokenGt(String),
        RefreshTokenGte(String),
        RefreshTokenContains(String),
        RefreshTokenStartsWith(String),
        RefreshTokenEndsWith(String),
        RefreshTokenMode(QueryMode),
        RefreshTokenNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtEquals(Option<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtLt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtLte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtNot(chrono::DateTime<chrono::FixedOffset>),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::EmailConnTypeEquals(email, conn_type) => (
                    "email_conn_type".to_string(),
                    SerializedWhereValue::Object(vec![
                        ("email".to_string(), PrismaValue::String(email)),
                        (
                            "conn_type".to_string(),
                            PrismaValue::Enum(conn_type.to_string()),
                        ),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ConnTypeEquals(value) => (
                    "conn_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EmailEquals(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailInVec(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::EmailNotInVec(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::EmailLt(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailLte(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGt(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGte(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailContains(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailStartsWith(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEndsWith(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::EmailMode(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EmailNot(value) => (
                    "email".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleEquals(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::HandleInVec(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HandleNotInVec(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HandleLt(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleLte(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleGt(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleGte(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleContains(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleStartsWith(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleEndsWith(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleMode(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::HandleNot(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenEquals(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::AccessTokenInVec(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AccessTokenNotInVec(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AccessTokenLt(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenLte(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenGt(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenGte(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenContains(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenStartsWith(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenEndsWith(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AccessTokenMode(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AccessTokenNot(value) => (
                    "accessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenEquals(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::RefreshTokenInVec(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::RefreshTokenNotInVec(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::RefreshTokenLt(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenLte(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenGt(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenGte(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenContains(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenStartsWith(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenEndsWith(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::RefreshTokenMode(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::RefreshTokenNot(value) => (
                    "refreshToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtEquals(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::DateTime(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::ExpiresAtInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtNotInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtLt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtLte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtNot(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        EmailConnTypeEquals(String, UserConnectionType),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailConnTypeEquals(email, conn_type) => {
                    Self::EmailConnTypeEquals(email, conn_type)
                }
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            conn_type: conn_type::Set,
            email: email::Set,
            user: user::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(conn_type.into());
            _params.push(email.into());
            _params.push(user.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("UserConnection", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("UserConnection", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("UserConnection", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("UserConnection", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (conn_type::Set, email::Set, user::Link, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (conn_type, email, user, mut _params) = _create;
            _params.push(conn_type.into());
            _params.push(email.into());
            _params.push(user.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("UserConnection", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod session {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtNot(value)
        }
        pub struct Set(Option<chrono::DateTime<chrono::FixedOffset>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
    }
    pub mod handle {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::HandleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Handle(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Handle(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HandleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HandleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HandleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HandleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HandleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HandleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HandleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HandleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HandleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::HandleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HandleNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHandle(value.0)
            }
        }
    }
    pub mod hashed_session_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::HashedSessionTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HashedSessionToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedSessionTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedSessionTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::HashedSessionTokenMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HashedSessionTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHashedSessionToken(value.0)
            }
        }
    }
    pub mod anti_csrf_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AntiCsrfTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AntiCsrfToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AntiCsrfTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AntiCsrfTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AntiCsrfTokenMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AntiCsrfTokenNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAntiCsrfToken(value.0)
            }
        }
    }
    pub mod public_data {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::PublicDataEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PublicData(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PublicDataInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PublicDataNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PublicDataLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PublicDataLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PublicDataGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PublicDataGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PublicDataContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PublicDataStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PublicDataEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::PublicDataMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PublicDataNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPublicData(value.0)
            }
        }
    }
    pub mod private_data {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::PrivateDataEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PrivateData(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PrivateDataInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PrivateDataNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PrivateDataLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PrivateDataLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PrivateDataGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PrivateDataGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PrivateDataContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PrivateDataStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PrivateDataEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::PrivateDataMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PrivateDataNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrivateData(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "expiresAt",
            "handle",
            "hashedSessionToken",
            "antiCSRFToken",
            "publicData",
            "privateData",
            "userId",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "expiresAt")]
        pub expires_at: Option<chrono::DateTime<chrono::FixedOffset>>,
        #[serde(rename = "handle")]
        pub handle: String,
        #[serde(rename = "hashedSessionToken")]
        pub hashed_session_token: Option<String>,
        #[serde(rename = "antiCSRFToken")]
        pub anti_csrf_token: Option<String>,
        #[serde(rename = "publicData")]
        pub public_data: Option<String>,
        #[serde(rename = "privateData")]
        pub private_data: Option<String>,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<String>,
    }
    impl Data {
        pub fn user(&self) -> Result<Option<&super::user::Data>, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetExpiresAt(Option<chrono::DateTime<chrono::FixedOffset>>),
        SetHandle(String),
        SetHashedSessionToken(Option<String>),
        SetAntiCsrfToken(Option<String>),
        SetPublicData(Option<String>),
        SetPrivateData(Option<String>),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(Option<String>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetExpiresAt(value) => (
                    "expiresAt".to_string(),
                    value
                        .map(|value| PrismaValue::DateTime(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetHandle(value) => ("handle".to_string(), PrismaValue::String(value)),
                SetParam::SetHashedSessionToken(value) => (
                    "hashedSessionToken".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetAntiCsrfToken(value) => (
                    "antiCSRFToken".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetPublicData(value) => (
                    "publicData".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetPrivateData(value) => (
                    "privateData".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        ExpiresAt(Direction),
        Handle(Direction),
        HashedSessionToken(Direction),
        AntiCsrfToken(Direction),
        PublicData(Direction),
        PrivateData(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ExpiresAt(direction) => (
                    "expiresAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Handle(direction) => (
                    "handle".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::HashedSessionToken(direction) => (
                    "hashedSessionToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AntiCsrfToken(direction) => (
                    "antiCSRFToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::PublicData(direction) => (
                    "publicData".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::PrivateData(direction) => (
                    "privateData".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Handle(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
                Self::Handle(cursor) => ("handle".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtEquals(Option<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtLt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtLte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtNot(chrono::DateTime<chrono::FixedOffset>),
        HandleEquals(String),
        HandleInVec(Vec<String>),
        HandleNotInVec(Vec<String>),
        HandleLt(String),
        HandleLte(String),
        HandleGt(String),
        HandleGte(String),
        HandleContains(String),
        HandleStartsWith(String),
        HandleEndsWith(String),
        HandleMode(QueryMode),
        HandleNot(String),
        HashedSessionTokenEquals(Option<String>),
        HashedSessionTokenInVec(Vec<String>),
        HashedSessionTokenNotInVec(Vec<String>),
        HashedSessionTokenLt(String),
        HashedSessionTokenLte(String),
        HashedSessionTokenGt(String),
        HashedSessionTokenGte(String),
        HashedSessionTokenContains(String),
        HashedSessionTokenStartsWith(String),
        HashedSessionTokenEndsWith(String),
        HashedSessionTokenMode(QueryMode),
        HashedSessionTokenNot(String),
        AntiCsrfTokenEquals(Option<String>),
        AntiCsrfTokenInVec(Vec<String>),
        AntiCsrfTokenNotInVec(Vec<String>),
        AntiCsrfTokenLt(String),
        AntiCsrfTokenLte(String),
        AntiCsrfTokenGt(String),
        AntiCsrfTokenGte(String),
        AntiCsrfTokenContains(String),
        AntiCsrfTokenStartsWith(String),
        AntiCsrfTokenEndsWith(String),
        AntiCsrfTokenMode(QueryMode),
        AntiCsrfTokenNot(String),
        PublicDataEquals(Option<String>),
        PublicDataInVec(Vec<String>),
        PublicDataNotInVec(Vec<String>),
        PublicDataLt(String),
        PublicDataLte(String),
        PublicDataGt(String),
        PublicDataGte(String),
        PublicDataContains(String),
        PublicDataStartsWith(String),
        PublicDataEndsWith(String),
        PublicDataMode(QueryMode),
        PublicDataNot(String),
        PrivateDataEquals(Option<String>),
        PrivateDataInVec(Vec<String>),
        PrivateDataNotInVec(Vec<String>),
        PrivateDataLt(String),
        PrivateDataLte(String),
        PrivateDataGt(String),
        PrivateDataGte(String),
        PrivateDataContains(String),
        PrivateDataStartsWith(String),
        PrivateDataEndsWith(String),
        PrivateDataMode(QueryMode),
        PrivateDataNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<String>),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtEquals(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::DateTime(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::ExpiresAtInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtNotInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtLt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtLte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtNot(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::HandleEquals(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleInVec(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HandleNotInVec(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HandleLt(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleLte(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleGt(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleGte(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleContains(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleStartsWith(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleEndsWith(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HandleMode(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::HandleNot(value) => (
                    "handle".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenEquals(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::HashedSessionTokenInVec(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedSessionTokenNotInVec(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedSessionTokenLt(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenLte(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenGt(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenGte(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenContains(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenStartsWith(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenEndsWith(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedSessionTokenMode(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::HashedSessionTokenNot(value) => (
                    "hashedSessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenEquals(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::AntiCsrfTokenInVec(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AntiCsrfTokenNotInVec(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AntiCsrfTokenLt(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenLte(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenGt(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenGte(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenContains(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenStartsWith(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenEndsWith(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AntiCsrfTokenMode(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AntiCsrfTokenNot(value) => (
                    "antiCSRFToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataEquals(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::PublicDataInVec(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::PublicDataNotInVec(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::PublicDataLt(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataLte(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataGt(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataGte(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataContains(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataStartsWith(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataEndsWith(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PublicDataMode(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::PublicDataNot(value) => (
                    "publicData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataEquals(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::PrivateDataInVec(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::PrivateDataNotInVec(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::PrivateDataLt(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataLte(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataGt(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataGte(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataContains(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataStartsWith(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataEndsWith(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::PrivateDataMode(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::PrivateDataNot(value) => (
                    "privateData".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        HandleEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::HandleEquals(value) => Self::HandleEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, handle: handle::Set, mut _params: Vec<SetParam>) -> Create {
            _params.push(handle.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Session", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Session", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Session", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Session", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (handle::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (handle, mut _params) = _create;
            _params.push(handle.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Session", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod token {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod hashed_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::HashedTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HashedToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HashedTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HashedTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HashedTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HashedTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HashedTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HashedTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HashedTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HashedTokenEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::HashedTokenMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HashedTokenNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHashedToken(value.0)
            }
        }
    }
    pub mod tok_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TokTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TokType(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokTypeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TokTypeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TokTypeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TokTypeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TokTypeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TokTypeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TokTypeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TokTypeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TokTypeEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TokTypeMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TokTypeNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTokType(value.0)
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::ExpiresAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::ExpiresAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
    }
    pub mod sent_to {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SentToEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::SentTo(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SentToInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SentToNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SentToLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SentToLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SentToGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SentToGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SentToContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SentToStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SentToEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::SentToMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SentToNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSentTo(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkUser
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn hashed_token_tok_type<T: From<UniqueWhereParam>>(
        hashed_token: String,
        tok_type: String,
    ) -> T {
        UniqueWhereParam::HashedTokenTokTypeEquals(hashed_token, tok_type).into()
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "hashedToken",
            "tok_type",
            "expiresAt",
            "sentTo",
            "userId",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "hashedToken")]
        pub hashed_token: String,
        #[serde(rename = "tok_type")]
        pub tok_type: String,
        #[serde(rename = "expiresAt")]
        pub expires_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "sentTo")]
        pub sent_to: String,
        #[serde(rename = "user")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
    }
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetHashedToken(String),
        SetTokType(String),
        SetExpiresAt(chrono::DateTime<chrono::FixedOffset>),
        SetSentTo(String),
        LinkUser(super::user::UniqueWhereParam),
        UnlinkUser,
        SetUserId(String),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetHashedToken(value) => {
                    ("hashedToken".to_string(), PrismaValue::String(value))
                }
                SetParam::SetTokType(value) => ("tok_type".to_string(), PrismaValue::String(value)),
                SetParam::SetExpiresAt(value) => {
                    ("expiresAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetSentTo(value) => ("sentTo".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkUser => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        HashedToken(Direction),
        TokType(Direction),
        ExpiresAt(Direction),
        SentTo(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::HashedToken(direction) => (
                    "hashedToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::TokType(direction) => (
                    "tok_type".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ExpiresAt(direction) => (
                    "expiresAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::SentTo(direction) => (
                    "sentTo".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        HashedTokenTokTypeEquals(String, String),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        HashedTokenEquals(String),
        HashedTokenInVec(Vec<String>),
        HashedTokenNotInVec(Vec<String>),
        HashedTokenLt(String),
        HashedTokenLte(String),
        HashedTokenGt(String),
        HashedTokenGte(String),
        HashedTokenContains(String),
        HashedTokenStartsWith(String),
        HashedTokenEndsWith(String),
        HashedTokenMode(QueryMode),
        HashedTokenNot(String),
        TokTypeEquals(String),
        TokTypeInVec(Vec<String>),
        TokTypeNotInVec(Vec<String>),
        TokTypeLt(String),
        TokTypeLte(String),
        TokTypeGt(String),
        TokTypeGte(String),
        TokTypeContains(String),
        TokTypeStartsWith(String),
        TokTypeEndsWith(String),
        TokTypeMode(QueryMode),
        TokTypeNot(String),
        ExpiresAtEquals(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        ExpiresAtLt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtLte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGt(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtGte(chrono::DateTime<chrono::FixedOffset>),
        ExpiresAtNot(chrono::DateTime<chrono::FixedOffset>),
        SentToEquals(String),
        SentToInVec(Vec<String>),
        SentToNotInVec(Vec<String>),
        SentToLt(String),
        SentToLte(String),
        SentToGt(String),
        SentToGte(String),
        SentToContains(String),
        SentToStartsWith(String),
        SentToEndsWith(String),
        SentToMode(QueryMode),
        SentToNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::HashedTokenTokTypeEquals(hashed_token, tok_type) => (
                    "hashedToken_tok_type".to_string(),
                    SerializedWhereValue::Object(vec![
                        ("hashedToken".to_string(), PrismaValue::String(hashed_token)),
                        ("tok_type".to_string(), PrismaValue::String(tok_type)),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::HashedTokenEquals(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenInVec(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedTokenNotInVec(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::HashedTokenLt(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenLte(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenGt(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenGte(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenContains(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenStartsWith(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenEndsWith(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::HashedTokenMode(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::HashedTokenNot(value) => (
                    "hashedToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeEquals(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeInVec(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TokTypeNotInVec(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TokTypeLt(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeLte(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeGt(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeGte(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeContains(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeStartsWith(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeEndsWith(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TokTypeMode(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TokTypeNot(value) => (
                    "tok_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ExpiresAtEquals(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtNotInVec(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExpiresAtLt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtLte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGt(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtGte(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAtNot(value) => (
                    "expiresAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::SentToEquals(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToInVec(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SentToNotInVec(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SentToLt(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToLte(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToGt(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToGte(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToContains(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToStartsWith(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToEndsWith(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SentToMode(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::SentToNot(value) => (
                    "sentTo".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
        HashedTokenTokTypeEquals(String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::HashedTokenTokTypeEquals(hashed_token, tok_type) => {
                    Self::HashedTokenTokTypeEquals(hashed_token, tok_type)
                }
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            hashed_token: hashed_token::Set,
            tok_type: tok_type::Set,
            expires_at: expires_at::Set,
            sent_to: sent_to::Set,
            user: user::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(hashed_token.into());
            _params.push(tok_type.into());
            _params.push(expires_at.into());
            _params.push(sent_to.into());
            _params.push(user.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Token", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Token", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Token", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Token", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (
                id::Set,
                hashed_token::Set,
                tok_type::Set,
                expires_at::Set,
                sent_to::Set,
                user::Link,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, hashed_token, tok_type, expires_at, sent_to, user, mut _params) = _create;
            _params.push(id.into());
            _params.push(hashed_token.into());
            _params.push(tok_type.into());
            _params.push(expires_at.into());
            _params.push(sent_to.into());
            _params.push(user.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Token", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod category {
    use super::_prisma::*;
    use super::*;
    pub mod slug {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::SlugEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Slug(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Slug(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SlugInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SlugNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SlugLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SlugLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SlugGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SlugGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SlugContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SlugStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SlugEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::SlugMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SlugNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSlug(value.0)
            }
        }
    }
    pub mod display {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Display(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DisplayLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DisplayLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DisplayGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DisplayGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DisplayContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DisplayStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DisplayEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DisplayMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DisplayNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDisplay(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod album {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIs(value)
        }
        pub fn is_not(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIsNot(value)
        }
        pub struct Fetch {
            args: album::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Album(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: album::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: album::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkAlbum
        }
        pub struct Link(album::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAlbum(value.0)
            }
        }
    }
    pub mod album_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AlbumIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AlbumId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AlbumIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AlbumIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AlbumIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AlbumIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AlbumIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AlbumIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AlbumIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AlbumIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AlbumIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAlbumId(value.0)
            }
        }
    }
    pub mod image {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImageIs(value)
        }
        pub fn is_not(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImageIsNot(value)
        }
        pub struct Fetch {
            args: image::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Image(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: image::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: image::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkImage
        }
        pub struct Link(image::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkImage(value.0)
            }
        }
    }
    pub mod image_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ImageIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ImageId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ImageIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ImageIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ImageIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ImageIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ImageIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ImageIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ImageIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ImageIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ImageIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetImageId(value.0)
            }
        }
    }
    pub mod lock_status {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: LockingStatus) -> T {
            Set(value).into()
        }
        pub fn equals(value: LockingStatus) -> WhereParam {
            WhereParam::LockStatusEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::LockStatus(direction)
        }
        pub struct Set(LockingStatus);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLockStatus(value.0)
            }
        }
    }
    pub mod rating {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: SafetyRating) -> T {
            Set(value).into()
        }
        pub fn equals(value: SafetyRating) -> WhereParam {
            WhereParam::RatingEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Rating(direction)
        }
        pub struct Set(SafetyRating);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRating(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "slug",
            "display",
            "createdAt",
            "updatedAt",
            "albumId",
            "imageId",
            "lockStatus",
            "rating",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "slug")]
        pub slug: String,
        #[serde(rename = "display")]
        pub display: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "album")]
        pub album: Option<Box<super::album::Data>>,
        #[serde(rename = "albumId")]
        pub album_id: String,
        #[serde(rename = "image")]
        pub image: Option<Box<super::image::Data>>,
        #[serde(rename = "imageId")]
        pub image_id: String,
        #[serde(rename = "lockStatus")]
        pub lock_status: LockingStatus,
        #[serde(rename = "rating")]
        pub rating: SafetyRating,
    }
    impl Data {
        pub fn album(&self) -> Result<&super::album::Data, &'static str> {
            self.album
                .as_ref()
                .ok_or("Attempted to access 'album' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn image(&self) -> Result<&super::image::Data, &'static str> {
            self.image
                .as_ref()
                .ok_or("Attempted to access 'image' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
    }
    pub enum WithParam {
        Album(super::album::UniqueArgs),
        Image(super::image::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Album(args) => {
                    let mut selections = super::album::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("album");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Image(args) => {
                    let mut selections = super::image::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("image");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetSlug(String),
        SetDisplay(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        LinkAlbum(super::album::UniqueWhereParam),
        UnlinkAlbum,
        SetAlbumId(String),
        LinkImage(super::image::UniqueWhereParam),
        UnlinkImage,
        SetImageId(String),
        SetLockStatus(LockingStatus),
        SetRating(SafetyRating),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetSlug(value) => ("slug".to_string(), PrismaValue::String(value)),
                SetParam::SetDisplay(value) => ("display".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::LinkAlbum(where_param) => (
                    "album".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::album::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkAlbum => (
                    "album".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetAlbumId(value) => ("albumId".to_string(), PrismaValue::String(value)),
                SetParam::LinkImage(where_param) => (
                    "image".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::image::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkImage => (
                    "image".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetImageId(value) => ("imageId".to_string(), PrismaValue::String(value)),
                SetParam::SetLockStatus(value) => (
                    "lockStatus".to_string(),
                    PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetRating(value) => {
                    ("rating".to_string(), PrismaValue::Enum(value.to_string()))
                }
            }
        }
    }
    pub enum OrderByParam {
        Slug(Direction),
        Display(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        AlbumId(Direction),
        ImageId(Direction),
        LockStatus(Direction),
        Rating(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Slug(direction) => (
                    "slug".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Display(direction) => (
                    "display".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AlbumId(direction) => (
                    "albumId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ImageId(direction) => (
                    "imageId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::LockStatus(direction) => (
                    "lockStatus".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Rating(direction) => (
                    "rating".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Slug(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Slug(cursor) => ("slug".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SlugEquals(String),
        SlugInVec(Vec<String>),
        SlugNotInVec(Vec<String>),
        SlugLt(String),
        SlugLte(String),
        SlugGt(String),
        SlugGte(String),
        SlugContains(String),
        SlugStartsWith(String),
        SlugEndsWith(String),
        SlugMode(QueryMode),
        SlugNot(String),
        DisplayEquals(String),
        DisplayInVec(Vec<String>),
        DisplayNotInVec(Vec<String>),
        DisplayLt(String),
        DisplayLte(String),
        DisplayGt(String),
        DisplayGte(String),
        DisplayContains(String),
        DisplayStartsWith(String),
        DisplayEndsWith(String),
        DisplayMode(QueryMode),
        DisplayNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        AlbumIs(Vec<super::album::WhereParam>),
        AlbumIsNot(Vec<super::album::WhereParam>),
        AlbumIdEquals(String),
        AlbumIdInVec(Vec<String>),
        AlbumIdNotInVec(Vec<String>),
        AlbumIdLt(String),
        AlbumIdLte(String),
        AlbumIdGt(String),
        AlbumIdGte(String),
        AlbumIdContains(String),
        AlbumIdStartsWith(String),
        AlbumIdEndsWith(String),
        AlbumIdMode(QueryMode),
        AlbumIdNot(String),
        ImageIs(Vec<super::image::WhereParam>),
        ImageIsNot(Vec<super::image::WhereParam>),
        ImageIdEquals(String),
        ImageIdInVec(Vec<String>),
        ImageIdNotInVec(Vec<String>),
        ImageIdLt(String),
        ImageIdLte(String),
        ImageIdGt(String),
        ImageIdGte(String),
        ImageIdContains(String),
        ImageIdStartsWith(String),
        ImageIdEndsWith(String),
        ImageIdMode(QueryMode),
        ImageIdNot(String),
        LockStatusEquals(LockingStatus),
        RatingEquals(SafetyRating),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::SlugEquals(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugInVec(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SlugNotInVec(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SlugLt(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugLte(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugGt(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugGte(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugContains(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugStartsWith(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugEndsWith(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SlugMode(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::SlugNot(value) => (
                    "slug".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayEquals(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayInVec(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DisplayNotInVec(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DisplayLt(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayLte(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayGt(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayGte(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayContains(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayStartsWith(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayEndsWith(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayMode(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DisplayNot(value) => (
                    "display".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::AlbumIs(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIsNot(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIdEquals(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdNotInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdLt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdLte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdContains(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdStartsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdEndsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdMode(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AlbumIdNot(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIs(value) => (
                    "image".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImageIsNot(value) => (
                    "image".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImageIdEquals(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdInVec(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageIdNotInVec(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageIdLt(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdLte(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdGt(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdGte(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdContains(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdStartsWith(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdEndsWith(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdMode(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ImageIdNot(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::LockStatusEquals(value) => (
                    "lockStatus".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::RatingEquals(value) => (
                    "rating".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        SlugEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SlugEquals(value) => Self::SlugEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            slug: slug::Set,
            display: display::Set,
            album: album::Link,
            image: image::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(slug.into());
            _params.push(display.into());
            _params.push(album.into());
            _params.push(image.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Category", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Category", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Category", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Category", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (
                slug::Set,
                display::Set,
                album::Link,
                image::Link,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (slug, display, album, image, mut _params) = _create;
            _params.push(slug.into());
            _params.push(display.into());
            _params.push(album.into());
            _params.push(image.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Category", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod image {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod image_ext {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ImageExtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ImageExt(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageExtInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageExtNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ImageExtLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ImageExtLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ImageExtGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ImageExtGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ImageExtContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ImageExtStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ImageExtEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ImageExtMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ImageExtNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetImageExt(value.0)
            }
        }
    }
    pub mod colors {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Colors(direction)
        }
        pub fn has(value: i32) -> WhereParam {
            WhereParam::ColorsHas(value)
        }
        pub fn has_every(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsHasEvery(value)
        }
        pub fn has_some(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsHasSome(value)
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::ColorsIsEmpty(value)
        }
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushColors(value)
        }
        pub struct Set(Vec<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetColors(value.0)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::DescriptionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DescriptionLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DescriptionLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DescriptionGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DescriptionGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DescriptionContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DescriptionStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DescriptionEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DescriptionMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DescriptionNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
    }
    pub mod author {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Author(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkAuthor
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAuthor(value.0)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AuthorIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AuthorIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AuthorIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AuthorIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AuthorIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AuthorIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AuthorIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AuthorIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AuthorIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AuthorIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAuthorId(value.0)
            }
        }
    }
    pub mod group {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIs(value)
        }
        pub fn is_not(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIsNot(value)
        }
        pub struct Fetch {
            args: group::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Group(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: group::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: group::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(group::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkGroup(value.0)
            }
        }
    }
    pub mod group_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::GroupIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::GroupId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GroupIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GroupIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GroupIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GroupIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GroupIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GroupIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GroupIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::GroupIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GroupIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGroupId(value.0)
            }
        }
    }
    pub mod categories {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesSome(value)
        }
        pub fn every(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesEvery(value)
        }
        pub fn none(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesNone(value)
        }
        pub struct Fetch {
            args: category::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<category::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: category::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<category::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Categories(fetch.args)
            }
        }
        pub fn fetch(params: Vec<category::WhereParam>) -> Fetch {
            Fetch {
                args: category::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<category::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<category::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkCategories(params)
        }
        pub struct Link(Vec<category::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkCategories(value.0)
            }
        }
    }
    pub mod album {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIs(value)
        }
        pub fn is_not(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIsNot(value)
        }
        pub struct Fetch {
            args: album::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Album(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: album::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: album::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkAlbum
        }
        pub struct Link(album::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAlbum(value.0)
            }
        }
    }
    pub mod album_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AlbumIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AlbumId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AlbumIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AlbumIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AlbumIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AlbumIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AlbumIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AlbumIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AlbumIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AlbumIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AlbumIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAlbumId(value.0)
            }
        }
    }
    pub mod lock_status {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: LockingStatus) -> T {
            Set(value).into()
        }
        pub fn equals(value: LockingStatus) -> WhereParam {
            WhereParam::LockStatusEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::LockStatus(direction)
        }
        pub struct Set(LockingStatus);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLockStatus(value.0)
            }
        }
    }
    pub mod rating {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: SafetyRating) -> T {
            Set(value).into()
        }
        pub fn equals(value: SafetyRating) -> WhereParam {
            WhereParam::RatingEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Rating(direction)
        }
        pub struct Set(SafetyRating);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRating(value.0)
            }
        }
    }
    pub mod user_favourites {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesNone(value)
        }
        pub struct Fetch {
            args: user::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<user::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::UserFavourites(fetch.args)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch {
                args: user::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<user::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkUserFavourites(params)
        }
        pub struct Link(Vec<user::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUserFavourites(value.0)
            }
        }
    }
    pub mod user_favourite_ids {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserFavouriteIds(direction)
        }
        pub fn has(value: String) -> WhereParam {
            WhereParam::UserFavouriteIdsHas(value)
        }
        pub fn has_every(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasEvery(value)
        }
        pub fn has_some(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasSome(value)
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::UserFavouriteIdsIsEmpty(value)
        }
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushUserFavouriteIds(value)
        }
        pub struct Set(Vec<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserFavouriteIds(value.0)
            }
        }
    }
    pub mod report {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportSome(value)
        }
        pub fn every(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportEvery(value)
        }
        pub fn none(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportNone(value)
        }
        pub struct Fetch {
            args: report::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<report::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: report::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<report::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Report(fetch.args)
            }
        }
        pub fn fetch(params: Vec<report::WhereParam>) -> Fetch {
            Fetch {
                args: report::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<report::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<report::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkReport(params)
        }
        pub struct Link(Vec<report::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkReport(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "imageExt",
            "colors",
            "title",
            "description",
            "authorId",
            "groupId",
            "albumId",
            "lockStatus",
            "rating",
            "userFavouriteIds",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "imageExt")]
        pub image_ext: String,
        #[serde(rename = "colors")]
        pub colors: Vec<i32>,
        #[serde(rename = "title")]
        pub title: Option<String>,
        #[serde(rename = "description")]
        pub description: Option<String>,
        #[serde(rename = "author")]
        pub author: Option<Box<super::user::Data>>,
        #[serde(rename = "authorId")]
        pub author_id: String,
        #[serde(
            rename = "group",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub group: Option<Option<Box<super::group::Data>>>,
        #[serde(rename = "groupId")]
        pub group_id: Option<String>,
        #[serde(rename = "categories")]
        pub categories: Option<Vec<super::category::Data>>,
        #[serde(rename = "album")]
        pub album: Option<Box<super::album::Data>>,
        #[serde(rename = "albumId")]
        pub album_id: String,
        #[serde(rename = "lockStatus")]
        pub lock_status: LockingStatus,
        #[serde(rename = "rating")]
        pub rating: SafetyRating,
        #[serde(rename = "userFavourites")]
        pub user_favourites: Option<Vec<super::user::Data>>,
        #[serde(rename = "userFavouriteIds")]
        pub user_favourite_ids: Vec<String>,
        #[serde(rename = "Report")]
        pub report: Option<Vec<super::report::Data>>,
    }
    impl Data {
        pub fn author(&self) -> Result<&super::user::Data, &'static str> {
            self.author
                .as_ref()
                .ok_or("Attempted to access 'author' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn group(&self) -> Result<Option<&super::group::Data>, &'static str> {
            self.group
                .as_ref()
                .ok_or("Attempted to access 'group' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn categories(&self) -> Result<&Vec<super::category::Data>, &'static str> {
            self.categories.as_ref().ok_or(
                "Attempted to access 'categories' but did not fetch it using the .with() syntax",
            )
        }
        pub fn album(&self) -> Result<&super::album::Data, &'static str> {
            self.album
                .as_ref()
                .ok_or("Attempted to access 'album' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn user_favourites(&self) -> Result<&Vec<super::user::Data>, &'static str> {
            self . user_favourites . as_ref () . ok_or ("Attempted to access 'user_favourites' but did not fetch it using the .with() syntax")
        }
        pub fn report(&self) -> Result<&Vec<super::report::Data>, &'static str> {
            self.report
                .as_ref()
                .ok_or("Attempted to access 'report' but did not fetch it using the .with() syntax")
        }
    }
    pub enum WithParam {
        Author(super::user::UniqueArgs),
        Group(super::group::UniqueArgs),
        Categories(super::category::ManyArgs),
        Album(super::album::UniqueArgs),
        UserFavourites(super::user::ManyArgs),
        Report(super::report::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Author(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("author");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Group(args) => {
                    let mut selections = super::group::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("group");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Categories(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::category::_outputs());
                    let mut builder = Selection::builder("categories");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Album(args) => {
                    let mut selections = super::album::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("album");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::UserFavourites(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user::_outputs());
                    let mut builder = Selection::builder("userFavourites");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Report(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::report::_outputs());
                    let mut builder = Selection::builder("Report");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetImageExt(String),
        SetColors(Vec<i32>),
        PushColors(Vec<i32>),
        SetTitle(Option<String>),
        SetDescription(Option<String>),
        LinkAuthor(super::user::UniqueWhereParam),
        UnlinkAuthor,
        SetAuthorId(String),
        LinkGroup(super::group::UniqueWhereParam),
        SetGroupId(Option<String>),
        LinkCategories(Vec<super::category::UniqueWhereParam>),
        UnlinkCategories(Vec<super::category::UniqueWhereParam>),
        LinkAlbum(super::album::UniqueWhereParam),
        UnlinkAlbum,
        SetAlbumId(String),
        SetLockStatus(LockingStatus),
        SetRating(SafetyRating),
        LinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        UnlinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        SetUserFavouriteIds(Vec<String>),
        PushUserFavouriteIds(Vec<String>),
        LinkReport(Vec<super::report::UniqueWhereParam>),
        UnlinkReport(Vec<super::report::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetImageExt(value) => {
                    ("imageExt".to_string(), PrismaValue::String(value))
                }
                SetParam::SetColors(value) => (
                    "colors".to_string(),
                    PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Int(v as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushColors(value) => (
                    "colors".to_string(),
                    PrismaValue::Object(vec![(
                        "push".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    "title".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetDescription(value) => (
                    "description".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkAuthor(where_param) => (
                    "author".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkAuthor => (
                    "author".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetAuthorId(value) => {
                    ("authorId".to_string(), PrismaValue::String(value))
                }
                SetParam::LinkGroup(where_param) => (
                    "group".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::group::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetGroupId(value) => (
                    "groupId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkCategories(where_params) => (
                    "categories".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::category::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkCategories(where_params) => (
                    "categories".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::category::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkAlbum(where_param) => (
                    "album".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::album::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkAlbum => (
                    "album".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetAlbumId(value) => ("albumId".to_string(), PrismaValue::String(value)),
                SetParam::SetLockStatus(value) => (
                    "lockStatus".to_string(),
                    PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetRating(value) => {
                    ("rating".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::LinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::user::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
                ),
                SetParam::PushUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::Object(vec![(
                        "push".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                SetParam::LinkReport(where_params) => (
                    "Report".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::report::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkReport(where_params) => (
                    "Report".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::report::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        ImageExt(Direction),
        Colors(Direction),
        Title(Direction),
        Description(Direction),
        AuthorId(Direction),
        GroupId(Direction),
        AlbumId(Direction),
        LockStatus(Direction),
        Rating(Direction),
        UserFavouriteIds(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ImageExt(direction) => (
                    "imageExt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Colors(direction) => (
                    "colors".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Description(direction) => (
                    "description".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AuthorId(direction) => (
                    "authorId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::GroupId(direction) => (
                    "groupId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AlbumId(direction) => (
                    "albumId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::LockStatus(direction) => (
                    "lockStatus".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Rating(direction) => (
                    "rating".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserFavouriteIds(direction) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        ImageExtEquals(String),
        ImageExtInVec(Vec<String>),
        ImageExtNotInVec(Vec<String>),
        ImageExtLt(String),
        ImageExtLte(String),
        ImageExtGt(String),
        ImageExtGte(String),
        ImageExtContains(String),
        ImageExtStartsWith(String),
        ImageExtEndsWith(String),
        ImageExtMode(QueryMode),
        ImageExtNot(String),
        ColorsEquals(Vec<i32>),
        ColorsHas(i32),
        ColorsHasEvery(Vec<i32>),
        ColorsHasSome(Vec<i32>),
        ColorsIsEmpty(bool),
        TitleEquals(Option<String>),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        DescriptionEquals(Option<String>),
        DescriptionInVec(Vec<String>),
        DescriptionNotInVec(Vec<String>),
        DescriptionLt(String),
        DescriptionLte(String),
        DescriptionGt(String),
        DescriptionGte(String),
        DescriptionContains(String),
        DescriptionStartsWith(String),
        DescriptionEndsWith(String),
        DescriptionMode(QueryMode),
        DescriptionNot(String),
        AuthorIs(Vec<super::user::WhereParam>),
        AuthorIsNot(Vec<super::user::WhereParam>),
        AuthorIdEquals(String),
        AuthorIdInVec(Vec<String>),
        AuthorIdNotInVec(Vec<String>),
        AuthorIdLt(String),
        AuthorIdLte(String),
        AuthorIdGt(String),
        AuthorIdGte(String),
        AuthorIdContains(String),
        AuthorIdStartsWith(String),
        AuthorIdEndsWith(String),
        AuthorIdMode(QueryMode),
        AuthorIdNot(String),
        GroupIs(Vec<super::group::WhereParam>),
        GroupIsNot(Vec<super::group::WhereParam>),
        GroupIdEquals(Option<String>),
        GroupIdInVec(Vec<String>),
        GroupIdNotInVec(Vec<String>),
        GroupIdLt(String),
        GroupIdLte(String),
        GroupIdGt(String),
        GroupIdGte(String),
        GroupIdContains(String),
        GroupIdStartsWith(String),
        GroupIdEndsWith(String),
        GroupIdMode(QueryMode),
        GroupIdNot(String),
        CategoriesSome(Vec<super::category::WhereParam>),
        CategoriesEvery(Vec<super::category::WhereParam>),
        CategoriesNone(Vec<super::category::WhereParam>),
        AlbumIs(Vec<super::album::WhereParam>),
        AlbumIsNot(Vec<super::album::WhereParam>),
        AlbumIdEquals(String),
        AlbumIdInVec(Vec<String>),
        AlbumIdNotInVec(Vec<String>),
        AlbumIdLt(String),
        AlbumIdLte(String),
        AlbumIdGt(String),
        AlbumIdGte(String),
        AlbumIdContains(String),
        AlbumIdStartsWith(String),
        AlbumIdEndsWith(String),
        AlbumIdMode(QueryMode),
        AlbumIdNot(String),
        LockStatusEquals(LockingStatus),
        RatingEquals(SafetyRating),
        UserFavouritesSome(Vec<super::user::WhereParam>),
        UserFavouritesEvery(Vec<super::user::WhereParam>),
        UserFavouritesNone(Vec<super::user::WhereParam>),
        UserFavouriteIdsEquals(Vec<String>),
        UserFavouriteIdsHas(String),
        UserFavouriteIdsHasEvery(Vec<String>),
        UserFavouriteIdsHasSome(Vec<String>),
        UserFavouriteIdsIsEmpty(bool),
        ReportSome(Vec<super::report::WhereParam>),
        ReportEvery(Vec<super::report::WhereParam>),
        ReportNone(Vec<super::report::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ImageExtEquals(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtInVec(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageExtNotInVec(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageExtLt(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtLte(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtGt(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtGte(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtContains(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtStartsWith(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtEndsWith(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageExtMode(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ImageExtNot(value) => (
                    "imageExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ColorsEquals(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsHas(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::ColorsHasEvery(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasEvery".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsHasSome(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasSome".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsIsEmpty(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isEmpty".to_string(),
                        PrismaValue::Boolean(value),
                    )]),
                ),
                Self::TitleEquals(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::TitleInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleNotInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleLt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleLte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleContains(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleStartsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleEndsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleMode(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleNot(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionEquals(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::DescriptionInVec(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DescriptionNotInVec(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DescriptionLt(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionLte(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionGt(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionGte(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionContains(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionStartsWith(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionEndsWith(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionMode(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DescriptionNot(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIs(value) => (
                    "author".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AuthorIsNot(value) => (
                    "author".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AuthorIdEquals(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdInVec(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AuthorIdNotInVec(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AuthorIdLt(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdLte(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdGt(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdGte(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdContains(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdStartsWith(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdEndsWith(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdMode(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AuthorIdNot(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIs(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIsNot(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIdEquals(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::GroupIdInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdNotInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdLt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdLte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdContains(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdStartsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdEndsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdMode(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::GroupIdNot(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CategoriesSome(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CategoriesEvery(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CategoriesNone(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIs(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIsNot(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIdEquals(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdNotInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdLt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdLte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdContains(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdStartsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdEndsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdMode(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AlbumIdNot(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::LockStatusEquals(value) => (
                    "lockStatus".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::RatingEquals(value) => (
                    "rating".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserFavouritesSome(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesEvery(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesNone(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouriteIdsEquals(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHas(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserFavouriteIdsHasEvery(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasEvery".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHasSome(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasSome".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsIsEmpty(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isEmpty".to_string(),
                        PrismaValue::Boolean(value),
                    )]),
                ),
                Self::ReportSome(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportEvery(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportNone(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            image_ext: image_ext::Set,
            author: author::Link,
            album: album::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(image_ext.into());
            _params.push(author.into());
            _params.push(album.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Image", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Image", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Image", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Image", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (
                id::Set,
                image_ext::Set,
                author::Link,
                album::Link,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, image_ext, author, album, mut _params) = _create;
            _params.push(id.into());
            _params.push(image_ext.into());
            _params.push(author.into());
            _params.push(album.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Image", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod album {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod cover_ext {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::CoverExtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CoverExt(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CoverExtInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CoverExtNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CoverExtLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CoverExtLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CoverExtGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CoverExtGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CoverExtContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CoverExtStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CoverExtEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::CoverExtMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CoverExtNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCoverExt(value.0)
            }
        }
    }
    pub mod colors {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Colors(direction)
        }
        pub fn has(value: i32) -> WhereParam {
            WhereParam::ColorsHas(value)
        }
        pub fn has_every(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsHasEvery(value)
        }
        pub fn has_some(value: Vec<i32>) -> WhereParam {
            WhereParam::ColorsHasSome(value)
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::ColorsIsEmpty(value)
        }
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushColors(value)
        }
        pub struct Set(Vec<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetColors(value.0)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::DescriptionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DescriptionNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DescriptionLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DescriptionLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DescriptionGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DescriptionGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DescriptionContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DescriptionStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DescriptionEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DescriptionMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DescriptionNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
    }
    pub mod author {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Author(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkAuthor
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAuthor(value.0)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AuthorIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AuthorIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AuthorIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AuthorIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AuthorIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AuthorIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AuthorIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AuthorIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AuthorIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AuthorIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAuthorId(value.0)
            }
        }
    }
    pub mod group {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIs(value)
        }
        pub fn is_not(value: Vec<group::WhereParam>) -> WhereParam {
            WhereParam::GroupIsNot(value)
        }
        pub struct Fetch {
            args: group::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<group::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Group(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: group::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: group::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(group::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkGroup(value.0)
            }
        }
    }
    pub mod group_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::GroupIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::GroupId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GroupIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GroupIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GroupIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GroupIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GroupIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GroupIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GroupIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GroupIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::GroupIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GroupIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGroupId(value.0)
            }
        }
    }
    pub mod images {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesSome(value)
        }
        pub fn every(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesEvery(value)
        }
        pub fn none(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImagesNone(value)
        }
        pub struct Fetch {
            args: image::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: image::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<image::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Images(fetch.args)
            }
        }
        pub fn fetch(params: Vec<image::WhereParam>) -> Fetch {
            Fetch {
                args: image::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<image::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<image::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkImages(params)
        }
        pub struct Link(Vec<image::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkImages(value.0)
            }
        }
    }
    pub mod categories {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesSome(value)
        }
        pub fn every(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesEvery(value)
        }
        pub fn none(value: Vec<category::WhereParam>) -> WhereParam {
            WhereParam::CategoriesNone(value)
        }
        pub struct Fetch {
            args: category::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<category::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: category::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<category::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Categories(fetch.args)
            }
        }
        pub fn fetch(params: Vec<category::WhereParam>) -> Fetch {
            Fetch {
                args: category::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<category::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<category::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkCategories(params)
        }
        pub struct Link(Vec<category::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkCategories(value.0)
            }
        }
    }
    pub mod lock_status {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: LockingStatus) -> T {
            Set(value).into()
        }
        pub fn equals(value: LockingStatus) -> WhereParam {
            WhereParam::LockStatusEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::LockStatus(direction)
        }
        pub struct Set(LockingStatus);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLockStatus(value.0)
            }
        }
    }
    pub mod rating {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: SafetyRating) -> T {
            Set(value).into()
        }
        pub fn equals(value: SafetyRating) -> WhereParam {
            WhereParam::RatingEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Rating(direction)
        }
        pub struct Set(SafetyRating);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRating(value.0)
            }
        }
    }
    pub mod user_favourites {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesSome(value)
        }
        pub fn every(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesEvery(value)
        }
        pub fn none(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserFavouritesNone(value)
        }
        pub struct Fetch {
            args: user::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<user::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::UserFavourites(fetch.args)
            }
        }
        pub fn fetch(params: Vec<user::WhereParam>) -> Fetch {
            Fetch {
                args: user::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<user::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<user::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkUserFavourites(params)
        }
        pub struct Link(Vec<user::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUserFavourites(value.0)
            }
        }
    }
    pub mod user_favourite_ids {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserFavouriteIds(direction)
        }
        pub fn has(value: String) -> WhereParam {
            WhereParam::UserFavouriteIdsHas(value)
        }
        pub fn has_every(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasEvery(value)
        }
        pub fn has_some(value: Vec<String>) -> WhereParam {
            WhereParam::UserFavouriteIdsHasSome(value)
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::UserFavouriteIdsIsEmpty(value)
        }
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushUserFavouriteIds(value)
        }
        pub struct Set(Vec<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserFavouriteIds(value.0)
            }
        }
    }
    pub mod report {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportSome(value)
        }
        pub fn every(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportEvery(value)
        }
        pub fn none(value: Vec<report::WhereParam>) -> WhereParam {
            WhereParam::ReportNone(value)
        }
        pub struct Fetch {
            args: report::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<report::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: report::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<report::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Report(fetch.args)
            }
        }
        pub fn fetch(params: Vec<report::WhereParam>) -> Fetch {
            Fetch {
                args: report::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<report::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<report::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkReport(params)
        }
        pub struct Link(Vec<report::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkReport(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "updatedAt",
            "coverExt",
            "colors",
            "title",
            "description",
            "authorId",
            "groupId",
            "lockStatus",
            "rating",
            "userFavouriteIds",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "coverExt")]
        pub cover_ext: String,
        #[serde(rename = "colors")]
        pub colors: Vec<i32>,
        #[serde(rename = "title")]
        pub title: Option<String>,
        #[serde(rename = "description")]
        pub description: Option<String>,
        #[serde(rename = "author")]
        pub author: Option<Box<super::user::Data>>,
        #[serde(rename = "authorId")]
        pub author_id: String,
        #[serde(
            rename = "group",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub group: Option<Option<Box<super::group::Data>>>,
        #[serde(rename = "groupId")]
        pub group_id: Option<String>,
        #[serde(rename = "images")]
        pub images: Option<Vec<super::image::Data>>,
        #[serde(rename = "categories")]
        pub categories: Option<Vec<super::category::Data>>,
        #[serde(rename = "lockStatus")]
        pub lock_status: LockingStatus,
        #[serde(rename = "rating")]
        pub rating: SafetyRating,
        #[serde(rename = "userFavourites")]
        pub user_favourites: Option<Vec<super::user::Data>>,
        #[serde(rename = "userFavouriteIds")]
        pub user_favourite_ids: Vec<String>,
        #[serde(rename = "Report")]
        pub report: Option<Vec<super::report::Data>>,
    }
    impl Data {
        pub fn author(&self) -> Result<&super::user::Data, &'static str> {
            self.author
                .as_ref()
                .ok_or("Attempted to access 'author' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn group(&self) -> Result<Option<&super::group::Data>, &'static str> {
            self.group
                .as_ref()
                .ok_or("Attempted to access 'group' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn images(&self) -> Result<&Vec<super::image::Data>, &'static str> {
            self.images
                .as_ref()
                .ok_or("Attempted to access 'images' but did not fetch it using the .with() syntax")
        }
        pub fn categories(&self) -> Result<&Vec<super::category::Data>, &'static str> {
            self.categories.as_ref().ok_or(
                "Attempted to access 'categories' but did not fetch it using the .with() syntax",
            )
        }
        pub fn user_favourites(&self) -> Result<&Vec<super::user::Data>, &'static str> {
            self . user_favourites . as_ref () . ok_or ("Attempted to access 'user_favourites' but did not fetch it using the .with() syntax")
        }
        pub fn report(&self) -> Result<&Vec<super::report::Data>, &'static str> {
            self.report
                .as_ref()
                .ok_or("Attempted to access 'report' but did not fetch it using the .with() syntax")
        }
    }
    pub enum WithParam {
        Author(super::user::UniqueArgs),
        Group(super::group::UniqueArgs),
        Images(super::image::ManyArgs),
        Categories(super::category::ManyArgs),
        UserFavourites(super::user::ManyArgs),
        Report(super::report::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Author(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("author");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Group(args) => {
                    let mut selections = super::group::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("group");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Images(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::image::_outputs());
                    let mut builder = Selection::builder("images");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Categories(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::category::_outputs());
                    let mut builder = Selection::builder("categories");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::UserFavourites(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::user::_outputs());
                    let mut builder = Selection::builder("userFavourites");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::Report(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::report::_outputs());
                    let mut builder = Selection::builder("Report");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetCoverExt(String),
        SetColors(Vec<i32>),
        PushColors(Vec<i32>),
        SetTitle(Option<String>),
        SetDescription(Option<String>),
        LinkAuthor(super::user::UniqueWhereParam),
        UnlinkAuthor,
        SetAuthorId(String),
        LinkGroup(super::group::UniqueWhereParam),
        SetGroupId(Option<String>),
        LinkImages(Vec<super::image::UniqueWhereParam>),
        UnlinkImages(Vec<super::image::UniqueWhereParam>),
        LinkCategories(Vec<super::category::UniqueWhereParam>),
        UnlinkCategories(Vec<super::category::UniqueWhereParam>),
        SetLockStatus(LockingStatus),
        SetRating(SafetyRating),
        LinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        UnlinkUserFavourites(Vec<super::user::UniqueWhereParam>),
        SetUserFavouriteIds(Vec<String>),
        PushUserFavouriteIds(Vec<String>),
        LinkReport(Vec<super::report::UniqueWhereParam>),
        UnlinkReport(Vec<super::report::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetCoverExt(value) => {
                    ("coverExt".to_string(), PrismaValue::String(value))
                }
                SetParam::SetColors(value) => (
                    "colors".to_string(),
                    PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Int(v as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushColors(value) => (
                    "colors".to_string(),
                    PrismaValue::Object(vec![(
                        "push".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    "title".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::SetDescription(value) => (
                    "description".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkAuthor(where_param) => (
                    "author".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkAuthor => (
                    "author".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetAuthorId(value) => {
                    ("authorId".to_string(), PrismaValue::String(value))
                }
                SetParam::LinkGroup(where_param) => (
                    "group".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::group::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetGroupId(value) => (
                    "groupId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::image::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkImages(where_params) => (
                    "images".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::image::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkCategories(where_params) => (
                    "categories".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::category::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkCategories(where_params) => (
                    "categories".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::category::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLockStatus(value) => (
                    "lockStatus".to_string(),
                    PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetRating(value) => {
                    ("rating".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::LinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkUserFavourites(where_params) => (
                    "userFavourites".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::user::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::List(value.into_iter().map(|v| PrismaValue::String(v)).collect()),
                ),
                SetParam::PushUserFavouriteIds(value) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::Object(vec![(
                        "push".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                SetParam::LinkReport(where_params) => (
                    "Report".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::report::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkReport(where_params) => (
                    "Report".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::report::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
        CoverExt(Direction),
        Colors(Direction),
        Title(Direction),
        Description(Direction),
        AuthorId(Direction),
        GroupId(Direction),
        LockStatus(Direction),
        Rating(Direction),
        UserFavouriteIds(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CoverExt(direction) => (
                    "coverExt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Colors(direction) => (
                    "colors".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Description(direction) => (
                    "description".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AuthorId(direction) => (
                    "authorId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::GroupId(direction) => (
                    "groupId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::LockStatus(direction) => (
                    "lockStatus".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Rating(direction) => (
                    "rating".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserFavouriteIds(direction) => (
                    "userFavouriteIds".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        CoverExtEquals(String),
        CoverExtInVec(Vec<String>),
        CoverExtNotInVec(Vec<String>),
        CoverExtLt(String),
        CoverExtLte(String),
        CoverExtGt(String),
        CoverExtGte(String),
        CoverExtContains(String),
        CoverExtStartsWith(String),
        CoverExtEndsWith(String),
        CoverExtMode(QueryMode),
        CoverExtNot(String),
        ColorsEquals(Vec<i32>),
        ColorsHas(i32),
        ColorsHasEvery(Vec<i32>),
        ColorsHasSome(Vec<i32>),
        ColorsIsEmpty(bool),
        TitleEquals(Option<String>),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        DescriptionEquals(Option<String>),
        DescriptionInVec(Vec<String>),
        DescriptionNotInVec(Vec<String>),
        DescriptionLt(String),
        DescriptionLte(String),
        DescriptionGt(String),
        DescriptionGte(String),
        DescriptionContains(String),
        DescriptionStartsWith(String),
        DescriptionEndsWith(String),
        DescriptionMode(QueryMode),
        DescriptionNot(String),
        AuthorIs(Vec<super::user::WhereParam>),
        AuthorIsNot(Vec<super::user::WhereParam>),
        AuthorIdEquals(String),
        AuthorIdInVec(Vec<String>),
        AuthorIdNotInVec(Vec<String>),
        AuthorIdLt(String),
        AuthorIdLte(String),
        AuthorIdGt(String),
        AuthorIdGte(String),
        AuthorIdContains(String),
        AuthorIdStartsWith(String),
        AuthorIdEndsWith(String),
        AuthorIdMode(QueryMode),
        AuthorIdNot(String),
        GroupIs(Vec<super::group::WhereParam>),
        GroupIsNot(Vec<super::group::WhereParam>),
        GroupIdEquals(Option<String>),
        GroupIdInVec(Vec<String>),
        GroupIdNotInVec(Vec<String>),
        GroupIdLt(String),
        GroupIdLte(String),
        GroupIdGt(String),
        GroupIdGte(String),
        GroupIdContains(String),
        GroupIdStartsWith(String),
        GroupIdEndsWith(String),
        GroupIdMode(QueryMode),
        GroupIdNot(String),
        ImagesSome(Vec<super::image::WhereParam>),
        ImagesEvery(Vec<super::image::WhereParam>),
        ImagesNone(Vec<super::image::WhereParam>),
        CategoriesSome(Vec<super::category::WhereParam>),
        CategoriesEvery(Vec<super::category::WhereParam>),
        CategoriesNone(Vec<super::category::WhereParam>),
        LockStatusEquals(LockingStatus),
        RatingEquals(SafetyRating),
        UserFavouritesSome(Vec<super::user::WhereParam>),
        UserFavouritesEvery(Vec<super::user::WhereParam>),
        UserFavouritesNone(Vec<super::user::WhereParam>),
        UserFavouriteIdsEquals(Vec<String>),
        UserFavouriteIdsHas(String),
        UserFavouriteIdsHasEvery(Vec<String>),
        UserFavouriteIdsHasSome(Vec<String>),
        UserFavouriteIdsIsEmpty(bool),
        ReportSome(Vec<super::report::WhereParam>),
        ReportEvery(Vec<super::report::WhereParam>),
        ReportNone(Vec<super::report::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CoverExtEquals(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtInVec(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::CoverExtNotInVec(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::CoverExtLt(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtLte(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtGt(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtGte(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtContains(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtStartsWith(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtEndsWith(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CoverExtMode(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::CoverExtNot(value) => (
                    "coverExt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ColorsEquals(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsHas(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::ColorsHasEvery(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasEvery".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsHasSome(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasSome".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ColorsIsEmpty(value) => (
                    "colors".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isEmpty".to_string(),
                        PrismaValue::Boolean(value),
                    )]),
                ),
                Self::TitleEquals(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::TitleInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleNotInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleLt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleLte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleContains(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleStartsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleEndsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleMode(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleNot(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionEquals(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::DescriptionInVec(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DescriptionNotInVec(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::DescriptionLt(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionLte(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionGt(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionGte(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionContains(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionStartsWith(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionEndsWith(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::DescriptionMode(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DescriptionNot(value) => (
                    "description".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIs(value) => (
                    "author".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AuthorIsNot(value) => (
                    "author".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AuthorIdEquals(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdInVec(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AuthorIdNotInVec(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AuthorIdLt(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdLte(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdGt(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdGte(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdContains(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdStartsWith(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdEndsWith(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorIdMode(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AuthorIdNot(value) => (
                    "authorId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIs(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIsNot(value) => (
                    "group".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::GroupIdEquals(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::GroupIdInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdNotInVec(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::GroupIdLt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdLte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGt(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdGte(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdContains(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdStartsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdEndsWith(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::GroupIdMode(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::GroupIdNot(value) => (
                    "groupId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImagesSome(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesEvery(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImagesNone(value) => (
                    "images".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CategoriesSome(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CategoriesEvery(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::CategoriesNone(value) => (
                    "categories".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::LockStatusEquals(value) => (
                    "lockStatus".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::RatingEquals(value) => (
                    "rating".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserFavouritesSome(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesEvery(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouritesNone(value) => (
                    "userFavourites".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserFavouriteIdsEquals(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHas(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserFavouriteIdsHasEvery(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasEvery".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsHasSome(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "hasSome".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserFavouriteIdsIsEmpty(value) => (
                    "userFavouriteIds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isEmpty".to_string(),
                        PrismaValue::Boolean(value),
                    )]),
                ),
                Self::ReportSome(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportEvery(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReportNone(value) => (
                    "Report".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            cover_ext: cover_ext::Set,
            author: author::Link,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(cover_ext.into());
            _params.push(author.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Album", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Album", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Album", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Album", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (id::Set, cover_ext::Set, author::Link, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, cover_ext, author, mut _params) = _create;
            _params.push(id.into());
            _params.push(cover_ext.into());
            _params.push(author.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Album", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod report {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod album {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIs(value)
        }
        pub fn is_not(value: Vec<album::WhereParam>) -> WhereParam {
            WhereParam::AlbumIsNot(value)
        }
        pub struct Fetch {
            args: album::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Album(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: album::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: album::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(album::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkAlbum(value.0)
            }
        }
    }
    pub mod album_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AlbumIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AlbumId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AlbumIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AlbumIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AlbumIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AlbumIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AlbumIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AlbumIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AlbumIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AlbumIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AlbumIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AlbumIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAlbumId(value.0)
            }
        }
    }
    pub mod image {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImageIs(value)
        }
        pub fn is_not(value: Vec<image::WhereParam>) -> WhereParam {
            WhereParam::ImageIsNot(value)
        }
        pub struct Fetch {
            args: image::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<image::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Image(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: image::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: image::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(image::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkImage(value.0)
            }
        }
    }
    pub mod image_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ImageIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ImageId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ImageIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ImageIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ImageIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ImageIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ImageIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ImageIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ImageIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ImageIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ImageIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ImageIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetImageId(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod reportee {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ReporteeIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ReporteeIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Reportee(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkReportee
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkReportee(value.0)
            }
        }
    }
    pub mod reportee_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReporteeIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::ReporteeId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReporteeIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReporteeIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReporteeIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReporteeIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReporteeIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReporteeIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReporteeIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReporteeIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReporteeIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReporteeIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReporteeIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReporteeId(value.0)
            }
        }
    }
    pub mod reason {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ReasonEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Reason(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReasonInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ReasonNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ReasonLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ReasonLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ReasonGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ReasonGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ReasonContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ReasonStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ReasonEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ReasonMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ReasonNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReason(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "createdAt",
            "albumId",
            "imageId",
            "userId",
            "reporteeId",
            "reason",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(
            rename = "album",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub album: Option<Option<Box<super::album::Data>>>,
        #[serde(rename = "albumId")]
        pub album_id: Option<String>,
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub image: Option<Option<Box<super::image::Data>>>,
        #[serde(rename = "imageId")]
        pub image_id: Option<String>,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<String>,
        #[serde(rename = "reportee")]
        pub reportee: Option<Box<super::user::Data>>,
        #[serde(rename = "reporteeId")]
        pub reportee_id: String,
        #[serde(rename = "reason")]
        pub reason: String,
    }
    impl Data {
        pub fn album(&self) -> Result<Option<&super::album::Data>, &'static str> {
            self.album
                .as_ref()
                .ok_or("Attempted to access 'album' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn image(&self) -> Result<Option<&super::image::Data>, &'static str> {
            self.image
                .as_ref()
                .ok_or("Attempted to access 'image' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn user(&self) -> Result<Option<&super::user::Data>, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn reportee(&self) -> Result<&super::user::Data, &'static str> {
            self.reportee
                .as_ref()
                .ok_or(
                    "Attempted to access 'reportee' but did not fetch it using the .with() syntax",
                )
                .map(|v| v.as_ref())
        }
    }
    pub enum WithParam {
        Album(super::album::UniqueArgs),
        Image(super::image::UniqueArgs),
        User(super::user::UniqueArgs),
        Reportee(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Album(args) => {
                    let mut selections = super::album::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("album");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Image(args) => {
                    let mut selections = super::image::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("image");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Reportee(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("reportee");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        LinkAlbum(super::album::UniqueWhereParam),
        SetAlbumId(Option<String>),
        LinkImage(super::image::UniqueWhereParam),
        SetImageId(Option<String>),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(Option<String>),
        LinkReportee(super::user::UniqueWhereParam),
        UnlinkReportee,
        SetReporteeId(String),
        SetReason(String),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::LinkAlbum(where_param) => (
                    "album".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::album::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetAlbumId(value) => (
                    "albumId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkImage(where_param) => (
                    "image".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::image::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetImageId(value) => (
                    "imageId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
                SetParam::LinkReportee(where_param) => (
                    "reportee".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::UnlinkReportee => (
                    "reportee".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetReporteeId(value) => {
                    ("reporteeId".to_string(), PrismaValue::String(value))
                }
                SetParam::SetReason(value) => ("reason".to_string(), PrismaValue::String(value)),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        AlbumId(Direction),
        ImageId(Direction),
        UserId(Direction),
        ReporteeId(Direction),
        Reason(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::AlbumId(direction) => (
                    "albumId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ImageId(direction) => (
                    "imageId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::ReporteeId(direction) => (
                    "reporteeId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Reason(direction) => (
                    "reason".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        AlbumIs(Vec<super::album::WhereParam>),
        AlbumIsNot(Vec<super::album::WhereParam>),
        AlbumIdEquals(Option<String>),
        AlbumIdInVec(Vec<String>),
        AlbumIdNotInVec(Vec<String>),
        AlbumIdLt(String),
        AlbumIdLte(String),
        AlbumIdGt(String),
        AlbumIdGte(String),
        AlbumIdContains(String),
        AlbumIdStartsWith(String),
        AlbumIdEndsWith(String),
        AlbumIdMode(QueryMode),
        AlbumIdNot(String),
        ImageIs(Vec<super::image::WhereParam>),
        ImageIsNot(Vec<super::image::WhereParam>),
        ImageIdEquals(Option<String>),
        ImageIdInVec(Vec<String>),
        ImageIdNotInVec(Vec<String>),
        ImageIdLt(String),
        ImageIdLte(String),
        ImageIdGt(String),
        ImageIdGte(String),
        ImageIdContains(String),
        ImageIdStartsWith(String),
        ImageIdEndsWith(String),
        ImageIdMode(QueryMode),
        ImageIdNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<String>),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
        ReporteeIs(Vec<super::user::WhereParam>),
        ReporteeIsNot(Vec<super::user::WhereParam>),
        ReporteeIdEquals(String),
        ReporteeIdInVec(Vec<String>),
        ReporteeIdNotInVec(Vec<String>),
        ReporteeIdLt(String),
        ReporteeIdLte(String),
        ReporteeIdGt(String),
        ReporteeIdGte(String),
        ReporteeIdContains(String),
        ReporteeIdStartsWith(String),
        ReporteeIdEndsWith(String),
        ReporteeIdMode(QueryMode),
        ReporteeIdNot(String),
        ReasonEquals(String),
        ReasonInVec(Vec<String>),
        ReasonNotInVec(Vec<String>),
        ReasonLt(String),
        ReasonLte(String),
        ReasonGt(String),
        ReasonGte(String),
        ReasonContains(String),
        ReasonStartsWith(String),
        ReasonEndsWith(String),
        ReasonMode(QueryMode),
        ReasonNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::AlbumIs(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIsNot(value) => (
                    "album".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::AlbumIdEquals(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::AlbumIdInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdNotInVec(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::AlbumIdLt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdLte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGt(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdGte(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdContains(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdStartsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdEndsWith(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::AlbumIdMode(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AlbumIdNot(value) => (
                    "albumId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIs(value) => (
                    "image".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImageIsNot(value) => (
                    "image".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ImageIdEquals(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::ImageIdInVec(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageIdNotInVec(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ImageIdLt(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdLte(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdGt(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdGte(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdContains(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdStartsWith(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdEndsWith(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ImageIdMode(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ImageIdNot(value) => (
                    "imageId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIs(value) => (
                    "reportee".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReporteeIsNot(value) => (
                    "reportee".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::ReporteeIdEquals(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdInVec(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ReporteeIdNotInVec(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ReporteeIdLt(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdLte(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdGt(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdGte(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdContains(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdStartsWith(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdEndsWith(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReporteeIdMode(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReporteeIdNot(value) => (
                    "reporteeId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonEquals(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonInVec(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ReasonNotInVec(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::ReasonLt(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonLte(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonGt(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonGte(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonContains(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonStartsWith(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonEndsWith(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::ReasonMode(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::ReasonNot(value) => (
                    "reason".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            reportee: reportee::Link,
            reason: reason::Set,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(id.into());
            _params.push(reportee.into());
            _params.push(reason.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Report", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Report", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Report", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Report", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (id::Set, reportee::Link, reason::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (id, reportee, reason, mut _params) = _create;
            _params.push(id.into());
            _params.push(reportee.into());
            _params.push(reason.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Report", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod notification {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod not_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: NotificationType) -> T {
            Set(value).into()
        }
        pub fn equals(value: NotificationType) -> WhereParam {
            WhereParam::NotTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::NotType(direction)
        }
        pub struct Set(NotificationType);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNotType(value.0)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
    }
    pub mod message {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MessageEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Message(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MessageInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MessageNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MessageLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MessageLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MessageGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MessageGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MessageContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MessageStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MessageEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MessageMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MessageNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessage(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "createdAt", "not_type", "title", "message", "userId"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "not_type")]
        pub not_type: NotificationType,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "message")]
        pub message: String,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<String>,
    }
    impl Data {
        pub fn user(&self) -> Result<Option<&super::user::Data>, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetNotType(NotificationType),
        SetTitle(String),
        SetMessage(String),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(Option<String>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetNotType(value) => {
                    ("not_type".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::SetTitle(value) => ("title".to_string(), PrismaValue::String(value)),
                SetParam::SetMessage(value) => ("message".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        NotType(Direction),
        Title(Direction),
        Message(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::NotType(direction) => (
                    "not_type".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Message(direction) => (
                    "message".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        NotTypeEquals(NotificationType),
        TitleEquals(String),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        MessageEquals(String),
        MessageInVec(Vec<String>),
        MessageNotInVec(Vec<String>),
        MessageLt(String),
        MessageLte(String),
        MessageGt(String),
        MessageGte(String),
        MessageContains(String),
        MessageStartsWith(String),
        MessageEndsWith(String),
        MessageMode(QueryMode),
        MessageNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<String>),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NotTypeEquals(value) => (
                    "not_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleEquals(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleNotInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleLt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleLte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleContains(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleStartsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleEndsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleMode(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleNot(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageEquals(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageInVec(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::MessageNotInVec(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::MessageLt(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageLte(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageGt(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageGte(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageContains(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageStartsWith(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageEndsWith(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageMode(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MessageNot(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            not_type: not_type::Set,
            title: title::Set,
            message: message::Set,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(not_type.into());
            _params.push(title.into());
            _params.push(message.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("Notification", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("Notification", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("Notification", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("Notification", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (not_type::Set, title::Set, message::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (not_type, title, message, mut _params) = _create;
            _params.push(not_type.into());
            _params.push(title.into());
            _params.push(message.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("Notification", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod moderator_notifications {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod not_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ModeratorNotificationsType) -> T {
            Set(value).into()
        }
        pub fn equals(value: ModeratorNotificationsType) -> WhereParam {
            WhereParam::NotTypeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::NotType(direction)
        }
        pub struct Set(ModeratorNotificationsType);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNotType(value.0)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
    }
    pub mod message {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MessageEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Message(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MessageInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MessageNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MessageLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MessageLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MessageGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MessageGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MessageContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MessageStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MessageEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::MessageMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MessageNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessage(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "createdAt", "not_type", "title", "message", "userId"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "not_type")]
        pub not_type: ModeratorNotificationsType,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "message")]
        pub message: String,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<String>,
    }
    impl Data {
        pub fn user(&self) -> Result<Option<&super::user::Data>, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    pub enum WithParam {
        User(super::user::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetNotType(ModeratorNotificationsType),
        SetTitle(String),
        SetMessage(String),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(Option<String>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetNotType(value) => {
                    ("not_type".to_string(), PrismaValue::Enum(value.to_string()))
                }
                SetParam::SetTitle(value) => ("title".to_string(), PrismaValue::String(value)),
                SetParam::SetMessage(value) => ("message".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::String(value))
                        .unwrap_or(PrismaValue::Null),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CreatedAt(Direction),
        NotType(Direction),
        Title(Direction),
        Message(Direction),
        UserId(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::NotType(direction) => (
                    "not_type".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::Message(direction) => (
                    "message".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        NotTypeEquals(ModeratorNotificationsType),
        TitleEquals(String),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        MessageEquals(String),
        MessageInVec(Vec<String>),
        MessageNotInVec(Vec<String>),
        MessageLt(String),
        MessageLte(String),
        MessageGt(String),
        MessageGte(String),
        MessageContains(String),
        MessageStartsWith(String),
        MessageEndsWith(String),
        MessageMode(QueryMode),
        MessageNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<String>),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdMode(QueryMode),
        UserIdNot(String),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::NotTypeEquals(value) => (
                    "not_type".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleEquals(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleNotInVec(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TitleLt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleLte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGt(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGte(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleContains(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleStartsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleEndsWith(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TitleMode(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleNot(value) => (
                    "title".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageEquals(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageInVec(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::MessageNotInVec(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::MessageLt(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageLte(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageGt(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageGte(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageContains(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageStartsWith(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageEndsWith(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::MessageMode(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::MessageNot(value) => (
                    "message".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value))
                            .unwrap_or(PrismaValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdMode(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            not_type: not_type::Set,
            title: title::Set,
            message: message::Set,
            mut _params: Vec<SetParam>,
        ) -> Create {
            _params.push(not_type.into());
            _params.push(title.into());
            _params.push(message.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("ModeratorNotifications", _outputs()),
                _params,
            )
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("ModeratorNotifications", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("ModeratorNotifications", _outputs()),
                params,
            )
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("ModeratorNotifications", _outputs()),
                params,
            )
        }
        pub fn upsert(
            &self,
            _where: UniqueWhereParam,
            _create: (not_type::Set, title::Set, message::Set, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert {
            let (not_type, title, message, mut _params) = _create;
            _params.push(not_type.into());
            _params.push(title.into());
            _params.push(message.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("ModeratorNotifications", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod _prisma {
    use super::*;
    use prisma_client_rust::{
        queries::QueryContext,
        query_core::{QueryExecutor, QuerySchema},
        raw, ExecuteRaw, QueryRaw,
    };
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::sync::Arc;
    pub struct PrismaClient {
        executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
        query_schema: Arc<QuerySchema>,
    }
    impl fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> QueryContext {
            QueryContext::new(&self.executor, self.query_schema.clone())
        }
        pub(super) fn _new(
            executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
            query_schema: Arc<QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub async fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: raw::Raw,
        ) -> QueryResult<Vec<T>> {
            QueryRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
            ExecuteRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub fn group(&self) -> group::Actions {
            group::Actions { client: &self }
        }
        pub fn group_member(&self) -> group_member::Actions {
            group_member::Actions { client: &self }
        }
        pub fn user(&self) -> user::Actions {
            user::Actions { client: &self }
        }
        pub fn user_connection(&self) -> user_connection::Actions {
            user_connection::Actions { client: &self }
        }
        pub fn session(&self) -> session::Actions {
            session::Actions { client: &self }
        }
        pub fn token(&self) -> token::Actions {
            token::Actions { client: &self }
        }
        pub fn category(&self) -> category::Actions {
            category::Actions { client: &self }
        }
        pub fn image(&self) -> image::Actions {
            image::Actions { client: &self }
        }
        pub fn album(&self) -> album::Actions {
            album::Actions { client: &self }
        }
        pub fn report(&self) -> report::Actions {
            report::Actions { client: &self }
        }
        pub fn notification(&self) -> notification::Actions {
            notification::Actions { client: &self }
        }
        pub fn moderator_notifications(&self) -> moderator_notifications::Actions {
            moderator_notifications::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum GroupScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "displayName")]
        DisplayName,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for GroupScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::Name => "name".to_string(),
                Self::DisplayName => "displayName".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum GroupMemberScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "groupId")]
        GroupId,
        #[serde(rename = "userId")]
        UserId,
        #[serde(rename = "invitedAt")]
        InvitedAt,
    }
    impl ToString for GroupMemberScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Role => "role".to_string(),
                Self::GroupId => "groupId".to_string(),
                Self::UserId => "userId".to_string(),
                Self::InvitedAt => "invitedAt".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "username")]
        Username,
        #[serde(rename = "nickname")]
        Nickname,
        #[serde(rename = "bio")]
        Bio,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "permissions")]
        Permissions,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "hashedPassword")]
        HashedPassword,
        #[serde(rename = "avatarUrl")]
        AvatarUrl,
        #[serde(rename = "avatarSourceId")]
        AvatarSourceId,
        #[serde(rename = "bannerExt")]
        BannerExt,
        #[serde(rename = "badges")]
        Badges,
        #[serde(rename = "lockStatus")]
        LockStatus,
        #[serde(rename = "premiumFeatures")]
        PremiumFeatures,
        #[serde(rename = "userFavouriteIds")]
        UserFavouriteIds,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::Username => "username".to_string(),
                Self::Nickname => "nickname".to_string(),
                Self::Bio => "bio".to_string(),
                Self::Role => "role".to_string(),
                Self::Permissions => "permissions".to_string(),
                Self::Email => "email".to_string(),
                Self::HashedPassword => "hashedPassword".to_string(),
                Self::AvatarUrl => "avatarUrl".to_string(),
                Self::AvatarSourceId => "avatarSourceId".to_string(),
                Self::BannerExt => "bannerExt".to_string(),
                Self::Badges => "badges".to_string(),
                Self::LockStatus => "lockStatus".to_string(),
                Self::PremiumFeatures => "premiumFeatures".to_string(),
                Self::UserFavouriteIds => "userFavouriteIds".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum UserConnectionScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "conn_type")]
        ConnType,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "handle")]
        Handle,
        #[serde(rename = "accessToken")]
        AccessToken,
        #[serde(rename = "refreshToken")]
        RefreshToken,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "expiresAt")]
        ExpiresAt,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for UserConnectionScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ConnType => "conn_type".to_string(),
                Self::Email => "email".to_string(),
                Self::Handle => "handle".to_string(),
                Self::AccessToken => "accessToken".to_string(),
                Self::RefreshToken => "refreshToken".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::ExpiresAt => "expiresAt".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum SessionScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "expiresAt")]
        ExpiresAt,
        #[serde(rename = "handle")]
        Handle,
        #[serde(rename = "hashedSessionToken")]
        HashedSessionToken,
        #[serde(rename = "antiCSRFToken")]
        AntiCsrfToken,
        #[serde(rename = "publicData")]
        PublicData,
        #[serde(rename = "privateData")]
        PrivateData,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for SessionScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::ExpiresAt => "expiresAt".to_string(),
                Self::Handle => "handle".to_string(),
                Self::HashedSessionToken => "hashedSessionToken".to_string(),
                Self::AntiCsrfToken => "antiCSRFToken".to_string(),
                Self::PublicData => "publicData".to_string(),
                Self::PrivateData => "privateData".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum TokenScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "hashedToken")]
        HashedToken,
        #[serde(rename = "tok_type")]
        TokType,
        #[serde(rename = "expiresAt")]
        ExpiresAt,
        #[serde(rename = "sentTo")]
        SentTo,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for TokenScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::HashedToken => "hashedToken".to_string(),
                Self::TokType => "tok_type".to_string(),
                Self::ExpiresAt => "expiresAt".to_string(),
                Self::SentTo => "sentTo".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum CategoryScalarFieldEnum {
        #[serde(rename = "slug")]
        Slug,
        #[serde(rename = "display")]
        Display,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "albumId")]
        AlbumId,
        #[serde(rename = "imageId")]
        ImageId,
        #[serde(rename = "lockStatus")]
        LockStatus,
        #[serde(rename = "rating")]
        Rating,
    }
    impl ToString for CategoryScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Slug => "slug".to_string(),
                Self::Display => "display".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::AlbumId => "albumId".to_string(),
                Self::ImageId => "imageId".to_string(),
                Self::LockStatus => "lockStatus".to_string(),
                Self::Rating => "rating".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum ImageScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "imageExt")]
        ImageExt,
        #[serde(rename = "colors")]
        Colors,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "authorId")]
        AuthorId,
        #[serde(rename = "groupId")]
        GroupId,
        #[serde(rename = "albumId")]
        AlbumId,
        #[serde(rename = "lockStatus")]
        LockStatus,
        #[serde(rename = "rating")]
        Rating,
        #[serde(rename = "userFavouriteIds")]
        UserFavouriteIds,
    }
    impl ToString for ImageScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::ImageExt => "imageExt".to_string(),
                Self::Colors => "colors".to_string(),
                Self::Title => "title".to_string(),
                Self::Description => "description".to_string(),
                Self::AuthorId => "authorId".to_string(),
                Self::GroupId => "groupId".to_string(),
                Self::AlbumId => "albumId".to_string(),
                Self::LockStatus => "lockStatus".to_string(),
                Self::Rating => "rating".to_string(),
                Self::UserFavouriteIds => "userFavouriteIds".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum AlbumScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
        #[serde(rename = "coverExt")]
        CoverExt,
        #[serde(rename = "colors")]
        Colors,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "authorId")]
        AuthorId,
        #[serde(rename = "groupId")]
        GroupId,
        #[serde(rename = "lockStatus")]
        LockStatus,
        #[serde(rename = "rating")]
        Rating,
        #[serde(rename = "userFavouriteIds")]
        UserFavouriteIds,
    }
    impl ToString for AlbumScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
                Self::CoverExt => "coverExt".to_string(),
                Self::Colors => "colors".to_string(),
                Self::Title => "title".to_string(),
                Self::Description => "description".to_string(),
                Self::AuthorId => "authorId".to_string(),
                Self::GroupId => "groupId".to_string(),
                Self::LockStatus => "lockStatus".to_string(),
                Self::Rating => "rating".to_string(),
                Self::UserFavouriteIds => "userFavouriteIds".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum ReportScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "albumId")]
        AlbumId,
        #[serde(rename = "imageId")]
        ImageId,
        #[serde(rename = "userId")]
        UserId,
        #[serde(rename = "reporteeId")]
        ReporteeId,
        #[serde(rename = "reason")]
        Reason,
    }
    impl ToString for ReportScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::AlbumId => "albumId".to_string(),
                Self::ImageId => "imageId".to_string(),
                Self::UserId => "userId".to_string(),
                Self::ReporteeId => "reporteeId".to_string(),
                Self::Reason => "reason".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum NotificationScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "not_type")]
        NotType,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "message")]
        Message,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for NotificationScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::NotType => "not_type".to_string(),
                Self::Title => "title".to_string(),
                Self::Message => "message".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum ModeratorNotificationsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "not_type")]
        NotType,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "message")]
        Message,
        #[serde(rename = "userId")]
        UserId,
    }
    impl ToString for ModeratorNotificationsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::NotType => "not_type".to_string(),
                Self::Title => "title".to_string(),
                Self::Message => "message".to_string(),
                Self::UserId => "userId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserBadge {
    #[serde(rename = "PREMIUM")]
    Premium,
    #[serde(rename = "MATURE")]
    Mature,
    #[serde(rename = "NOT_SAFE")]
    NotSafe,
    #[serde(rename = "SAFE")]
    Safe,
    #[serde(rename = "TRUSTED")]
    Trusted,
    #[serde(rename = "MODERATOR")]
    Moderator,
    #[serde(rename = "ADMINISTRATOR")]
    Administrator,
    #[serde(rename = "SUPERADMIN")]
    Superadmin,
}
impl ToString for UserBadge {
    fn to_string(&self) -> String {
        match self {
            Self::Premium => "PREMIUM".to_string(),
            Self::Mature => "MATURE".to_string(),
            Self::NotSafe => "NOT_SAFE".to_string(),
            Self::Safe => "SAFE".to_string(),
            Self::Trusted => "TRUSTED".to_string(),
            Self::Moderator => "MODERATOR".to_string(),
            Self::Administrator => "ADMINISTRATOR".to_string(),
            Self::Superadmin => "SUPERADMIN".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum PremiumFeature {
    #[serde(rename = "CUSTOM_PROFILE")]
    CustomProfile,
    #[serde(rename = "UNLIMITED_UPLOADS")]
    UnlimitedUploads,
}
impl ToString for PremiumFeature {
    fn to_string(&self) -> String {
        match self {
            Self::CustomProfile => "CUSTOM_PROFILE".to_string(),
            Self::UnlimitedUploads => "UNLIMITED_UPLOADS".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SafetyRating {
    #[serde(rename = "TRUSTED")]
    Trusted,
    #[serde(rename = "SAFE")]
    Safe,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "NOT_SAFE")]
    NotSafe,
    #[serde(rename = "MATURE")]
    Mature,
}
impl ToString for SafetyRating {
    fn to_string(&self) -> String {
        match self {
            Self::Trusted => "TRUSTED".to_string(),
            Self::Safe => "SAFE".to_string(),
            Self::Unknown => "UNKNOWN".to_string(),
            Self::NotSafe => "NOT_SAFE".to_string(),
            Self::Mature => "MATURE".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LockingStatus {
    #[serde(rename = "LOCKED")]
    Locked,
    #[serde(rename = "HIDDEN")]
    Hidden,
    #[serde(rename = "NONE")]
    None,
}
impl ToString for LockingStatus {
    fn to_string(&self) -> String {
        match self {
            Self::Locked => "LOCKED".to_string(),
            Self::Hidden => "HIDDEN".to_string(),
            Self::None => "NONE".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserConnectionType {
    #[serde(rename = "EMAIL")]
    Email,
    #[serde(rename = "GOOGLE")]
    Google,
    #[serde(rename = "DISCORD")]
    Discord,
    #[serde(rename = "TWITTER")]
    Twitter,
    #[serde(rename = "LINKEDIN")]
    Linkedin,
}
impl ToString for UserConnectionType {
    fn to_string(&self) -> String {
        match self {
            Self::Email => "EMAIL".to_string(),
            Self::Google => "GOOGLE".to_string(),
            Self::Discord => "DISCORD".to_string(),
            Self::Twitter => "TWITTER".to_string(),
            Self::Linkedin => "LINKEDIN".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum GroupMemberRole {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "ADMINISTRATOR")]
    Administrator,
    #[serde(rename = "OWNER")]
    Owner,
}
impl ToString for GroupMemberRole {
    fn to_string(&self) -> String {
        match self {
            Self::None => "NONE".to_string(),
            Self::Administrator => "ADMINISTRATOR".to_string(),
            Self::Owner => "OWNER".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserRole {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "MATURE")]
    Mature,
    #[serde(rename = "NOT_SAFE")]
    NotSafe,
    #[serde(rename = "SAFE")]
    Safe,
    #[serde(rename = "TRUSTED")]
    Trusted,
    #[serde(rename = "MODERATOR")]
    Moderator,
    #[serde(rename = "ADMINISTRATOR")]
    Administrator,
    #[serde(rename = "SUPERADMIN")]
    Superadmin,
}
impl ToString for UserRole {
    fn to_string(&self) -> String {
        match self {
            Self::None => "NONE".to_string(),
            Self::Mature => "MATURE".to_string(),
            Self::NotSafe => "NOT_SAFE".to_string(),
            Self::Safe => "SAFE".to_string(),
            Self::Trusted => "TRUSTED".to_string(),
            Self::Moderator => "MODERATOR".to_string(),
            Self::Administrator => "ADMINISTRATOR".to_string(),
            Self::Superadmin => "SUPERADMIN".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ReportReason {
    #[serde(rename = "MATURE")]
    Mature,
    #[serde(rename = "SPAM")]
    Spam,
    #[serde(rename = "VIOLENCE")]
    Violence,
    #[serde(rename = "HARASSMENT")]
    Harassment,
    #[serde(rename = "OTHER")]
    Other,
}
impl ToString for ReportReason {
    fn to_string(&self) -> String {
        match self {
            Self::Mature => "MATURE".to_string(),
            Self::Spam => "SPAM".to_string(),
            Self::Violence => "VIOLENCE".to_string(),
            Self::Harassment => "HARASSMENT".to_string(),
            Self::Other => "OTHER".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum NotificationType {
    #[serde(rename = "RANDOM_INFO")]
    RandomInfo,
    #[serde(rename = "NEW_FAVOURITE")]
    NewFavourite,
    #[serde(rename = "NEW_FOLLOWER")]
    NewFollower,
    #[serde(rename = "SUBSCRIPTION_ACTIVE")]
    SubscriptionActive,
    #[serde(rename = "SUBSCRIPTION_EXPIRING_SOON")]
    SubscriptionExpiringSoon,
    #[serde(rename = "SUBSCRIPTION_EXPIRED")]
    SubscriptionExpired,
    #[serde(rename = "USER_MARKED_AS_MATURE_BY_MODERATOR")]
    UserMarkedAsMatureByModerator,
    #[serde(rename = "USER_MARKED_AS_NOT_MATURE_BY_MODERATOR")]
    UserMarkedAsNotMatureByModerator,
    #[serde(rename = "USER_MARKED_AS_TRUSTED_BY_MODERATOR")]
    UserMarkedAsTrustedByModerator,
    #[serde(rename = "USER_MARKED_AS_NOT_TRUSTED_BY_MODERATOR")]
    UserMarkedAsNotTrustedByModerator,
    #[serde(rename = "ALBUM_LOCKED_BY_MODERATOR")]
    AlbumLockedByModerator,
    #[serde(rename = "ALBUM_UNLOCKED_BY_MODERATOR")]
    AlbumUnlockedByModerator,
    #[serde(rename = "ALBUM_DELETED_BY_MODERATOR")]
    AlbumDeletedByModerator,
    #[serde(rename = "IMAGE_LOCKED_BY_MODERATOR")]
    ImageLockedByModerator,
    #[serde(rename = "IMAGE_UNLOCKED_BY_MODERATOR")]
    ImageUnlockedByModerator,
    #[serde(rename = "IMAGE_DELETED_BY_MODERATOR")]
    ImageDeletedByModerator,
    #[serde(rename = "NEW_GROUP_INVITE")]
    NewGroupInvite,
    #[serde(rename = "GROUP_MEMBER_JOINED")]
    GroupMemberJoined,
    #[serde(rename = "GROUP_MEMBER_LEFT")]
    GroupMemberLeft,
    #[serde(rename = "GROUP_MEMBER_INVITE_ACCEPTED")]
    GroupMemberInviteAccepted,
    #[serde(rename = "GROUP_MEMBER_INVITE_DECLINED")]
    GroupMemberInviteDeclined,
    #[serde(rename = "GROUP_MEMBER_INVITE_EXPIRED")]
    GroupMemberInviteExpired,
}
impl ToString for NotificationType {
    fn to_string(&self) -> String {
        match self {
            Self::RandomInfo => "RANDOM_INFO".to_string(),
            Self::NewFavourite => "NEW_FAVOURITE".to_string(),
            Self::NewFollower => "NEW_FOLLOWER".to_string(),
            Self::SubscriptionActive => "SUBSCRIPTION_ACTIVE".to_string(),
            Self::SubscriptionExpiringSoon => "SUBSCRIPTION_EXPIRING_SOON".to_string(),
            Self::SubscriptionExpired => "SUBSCRIPTION_EXPIRED".to_string(),
            Self::UserMarkedAsMatureByModerator => "USER_MARKED_AS_MATURE_BY_MODERATOR".to_string(),
            Self::UserMarkedAsNotMatureByModerator => {
                "USER_MARKED_AS_NOT_MATURE_BY_MODERATOR".to_string()
            }
            Self::UserMarkedAsTrustedByModerator => {
                "USER_MARKED_AS_TRUSTED_BY_MODERATOR".to_string()
            }
            Self::UserMarkedAsNotTrustedByModerator => {
                "USER_MARKED_AS_NOT_TRUSTED_BY_MODERATOR".to_string()
            }
            Self::AlbumLockedByModerator => "ALBUM_LOCKED_BY_MODERATOR".to_string(),
            Self::AlbumUnlockedByModerator => "ALBUM_UNLOCKED_BY_MODERATOR".to_string(),
            Self::AlbumDeletedByModerator => "ALBUM_DELETED_BY_MODERATOR".to_string(),
            Self::ImageLockedByModerator => "IMAGE_LOCKED_BY_MODERATOR".to_string(),
            Self::ImageUnlockedByModerator => "IMAGE_UNLOCKED_BY_MODERATOR".to_string(),
            Self::ImageDeletedByModerator => "IMAGE_DELETED_BY_MODERATOR".to_string(),
            Self::NewGroupInvite => "NEW_GROUP_INVITE".to_string(),
            Self::GroupMemberJoined => "GROUP_MEMBER_JOINED".to_string(),
            Self::GroupMemberLeft => "GROUP_MEMBER_LEFT".to_string(),
            Self::GroupMemberInviteAccepted => "GROUP_MEMBER_INVITE_ACCEPTED".to_string(),
            Self::GroupMemberInviteDeclined => "GROUP_MEMBER_INVITE_DECLINED".to_string(),
            Self::GroupMemberInviteExpired => "GROUP_MEMBER_INVITE_EXPIRED".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ModeratorNotificationsType {
    #[serde(rename = "NEW_REPORT")]
    NewReport,
    #[serde(rename = "SUSPICIOUS_ACTIVITY")]
    SuspiciousActivity,
}
impl ToString for ModeratorNotificationsType {
    fn to_string(&self) -> String {
        match self {
            Self::NewReport => "NEW_REPORT".to_string(),
            Self::SuspiciousActivity => "SUSPICIOUS_ACTIVITY".to_string(),
        }
    }
}
